/**
 * Kestra EE
 * All API operations, except for Superadmin-only endpoints, require a tenant identifier in the HTTP path.<br/> Endpoints designated as Superadmin-only are not tenant-scoped.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import AppsControllerApiBulkImportResponse from '../model/AppsControllerApiBulkImportResponse';
import BulkResponse from '../model/BulkResponse';
import DeleteExecutionsByQueryRequest from '../model/DeleteExecutionsByQueryRequest';
import Flow from '../model/Flow';
import FlowControllerTaskValidationType from '../model/FlowControllerTaskValidationType';
import FlowGraph from '../model/FlowGraph';
import FlowInterface from '../model/FlowInterface';
import FlowScope from '../model/FlowScope';
import FlowTopologyGraph from '../model/FlowTopologyGraph';
import FlowWithSource from '../model/FlowWithSource';
import IdWithNamespace from '../model/IdWithNamespace';
import PagedResultsFlow from '../model/PagedResultsFlow';
import PagedResultsSearchResultFlow from '../model/PagedResultsSearchResultFlow';
import QueryFilter from '../model/QueryFilter';
import Task from '../model/Task';
import UpdateFlow200Response from '../model/UpdateFlow200Response';
import UpdateFlowsInNamespaceFromJson200Response from '../model/UpdateFlowsInNamespaceFromJson200Response';
import ValidateConstraintViolation from '../model/ValidateConstraintViolation';

/**
* Flows service.
* @module api/FlowsApi
* @version 1.0.0
*/
export default class FlowsApi {

    /**
    * Constructs a new FlowsApi. 
    * @alias module:api/FlowsApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }


    /**
     * Callback function to receive the result of the bulkImportApps operation.
     * @callback module:api/FlowsApi~bulkImportAppsCallback
     * @param {String} error Error message, if any.
     * @param {module:model/AppsControllerApiBulkImportResponse} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     *     Import apps as a ZIP archive of yaml sources or a multi-objects YAML file.     When sending a Yaml that contains one or more apps, a list of index is returned.     When sending a ZIP archive, a list of files that couldn't be imported is returned. 
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {File} [fileUpload] The file to import, can be a ZIP archive or a multi-objects YAML file
     * @param {module:api/FlowsApi~bulkImportAppsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/AppsControllerApiBulkImportResponse}
     */
    bulkImportApps(tenant, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling bulkImportApps");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
        'fileUpload': opts['fileUpload']
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['multipart/form-data'];
      let accepts = ['application/json'];
      let returnType = AppsControllerApiBulkImportResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/apps/import', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the bulkUpdateFlows operation.
     * @callback module:api/FlowsApi~bulkUpdateFlowsCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/FlowInterface>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Update from multiples yaml sources
     * All flow will be created / updated for this namespace. Flow that already created but not in `flows` will be deleted if the query delete is `true`
     * @param {Boolean} _delete If missing flow should be deleted
     * @param {Boolean} allowNamespaceChild If namespace child should are allowed to be updated
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {String} [namespace] The namespace where to update flows
     * @param {String} [body] A list of flows source code splitted with \"---\"
     * @param {module:api/FlowsApi~bulkUpdateFlowsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/FlowInterface>}
     */
    bulkUpdateFlows(_delete, allowNamespaceChild, tenant, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter '_delete' is set
      if (_delete === undefined || _delete === null) {
        throw new Error("Missing the required parameter '_delete' when calling bulkUpdateFlows");
      }
      // verify the required parameter 'allowNamespaceChild' is set
      if (allowNamespaceChild === undefined || allowNamespaceChild === null) {
        throw new Error("Missing the required parameter 'allowNamespaceChild' when calling bulkUpdateFlows");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling bulkUpdateFlows");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'delete': _delete,
        'namespace': opts['namespace'],
        'allowNamespaceChild': allowNamespaceChild
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/x-yaml'];
      let accepts = ['application/json'];
      let returnType = [FlowInterface];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/bulk', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the createFlow operation.
     * @callback module:api/FlowsApi~createFlowCallback
     * @param {String} error Error message, if any.
     * @param {module:model/FlowWithSource} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Create a flow from yaml source
     * @param {String} tenant 
     * @param {String} body The flow source code
     * @param {module:api/FlowsApi~createFlowCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/FlowWithSource}
     */
    createFlow(tenant, body, callback) {
      let postBody = body;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling createFlow");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createFlow");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/x-yaml'];
      let accepts = ['application/json'];
      let returnType = FlowWithSource;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteFlow operation.
     * @callback module:api/FlowsApi~deleteFlowCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Delete a flow
     * @param {String} namespace The flow namespace
     * @param {String} id The flow id
     * @param {String} tenant 
     * @param {module:api/FlowsApi~deleteFlowCallback} callback The callback function, accepting three arguments: error, data, response
     */
    deleteFlow(namespace, id, tenant, callback) {
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling deleteFlow");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteFlow");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling deleteFlow");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteFlowsByIds operation.
     * @callback module:api/FlowsApi~deleteFlowsByIdsCallback
     * @param {String} error Error message, if any.
     * @param {module:model/BulkResponse} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Delete flows by their IDs.
     * @param {String} tenant 
     * @param {Array.<module:model/IdWithNamespace>} idWithNamespace A list of tuple flow ID and namespace as flow identifiers
     * @param {module:api/FlowsApi~deleteFlowsByIdsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/BulkResponse}
     */
    deleteFlowsByIds(tenant, idWithNamespace, callback) {
      let postBody = idWithNamespace;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling deleteFlowsByIds");
      }
      // verify the required parameter 'idWithNamespace' is set
      if (idWithNamespace === undefined || idWithNamespace === null) {
        throw new Error("Missing the required parameter 'idWithNamespace' when calling deleteFlowsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/delete/by-ids', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the deleteFlowsByQuery operation.
     * @callback module:api/FlowsApi~deleteFlowsByQueryCallback
     * @param {String} error Error message, if any.
     * @param {module:model/BulkResponse} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Delete flows returned by the query parameters.
     * @param {String} tenant 
     * @param {module:model/DeleteExecutionsByQueryRequest} deleteExecutionsByQueryRequest 
     * @param {Object} opts Optional parameters
     * @param {String} [q] A string filter
     * @param {Array.<module:model/FlowScope>} [scope] The scope of the flows to include
     * @param {String} [namespace] A namespace filter prefix
     * @param {Array.<String>} [labels] A labels filter as a list of 'key:value'
     * @param {module:api/FlowsApi~deleteFlowsByQueryCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/BulkResponse}
     */
    deleteFlowsByQuery(tenant, deleteExecutionsByQueryRequest, opts, callback) {
      opts = opts || {};
      let postBody = deleteExecutionsByQueryRequest;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling deleteFlowsByQuery");
      }
      // verify the required parameter 'deleteExecutionsByQueryRequest' is set
      if (deleteExecutionsByQueryRequest === undefined || deleteExecutionsByQueryRequest === null) {
        throw new Error("Missing the required parameter 'deleteExecutionsByQueryRequest' when calling deleteFlowsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'q': opts['q'],
        'scope': this.apiClient.buildCollectionParam(opts['scope'], 'csv'),
        'namespace': opts['namespace'],
        'labels': this.apiClient.buildCollectionParam(opts['labels'], 'multi')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/delete/by-query', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the disableFlowsByIds operation.
     * @callback module:api/FlowsApi~disableFlowsByIdsCallback
     * @param {String} error Error message, if any.
     * @param {module:model/BulkResponse} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Disable flows by their IDs.
     * @param {String} tenant 
     * @param {Array.<module:model/IdWithNamespace>} idWithNamespace A list of tuple flow ID and namespace as flow identifiers
     * @param {module:api/FlowsApi~disableFlowsByIdsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/BulkResponse}
     */
    disableFlowsByIds(tenant, idWithNamespace, callback) {
      let postBody = idWithNamespace;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling disableFlowsByIds");
      }
      // verify the required parameter 'idWithNamespace' is set
      if (idWithNamespace === undefined || idWithNamespace === null) {
        throw new Error("Missing the required parameter 'idWithNamespace' when calling disableFlowsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/disable/by-ids', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the disableFlowsByQuery operation.
     * @callback module:api/FlowsApi~disableFlowsByQueryCallback
     * @param {String} error Error message, if any.
     * @param {module:model/BulkResponse} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Disable flows returned by the query parameters.
     * @param {String} tenant 
     * @param {module:model/DeleteExecutionsByQueryRequest} deleteExecutionsByQueryRequest 
     * @param {Object} opts Optional parameters
     * @param {String} [q] A string filter
     * @param {Array.<module:model/FlowScope>} [scope] The scope of the flows to include
     * @param {String} [namespace] A namespace filter prefix
     * @param {Array.<String>} [labels] A labels filter as a list of 'key:value'
     * @param {module:api/FlowsApi~disableFlowsByQueryCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/BulkResponse}
     */
    disableFlowsByQuery(tenant, deleteExecutionsByQueryRequest, opts, callback) {
      opts = opts || {};
      let postBody = deleteExecutionsByQueryRequest;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling disableFlowsByQuery");
      }
      // verify the required parameter 'deleteExecutionsByQueryRequest' is set
      if (deleteExecutionsByQueryRequest === undefined || deleteExecutionsByQueryRequest === null) {
        throw new Error("Missing the required parameter 'deleteExecutionsByQueryRequest' when calling disableFlowsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'q': opts['q'],
        'scope': this.apiClient.buildCollectionParam(opts['scope'], 'csv'),
        'namespace': opts['namespace'],
        'labels': this.apiClient.buildCollectionParam(opts['labels'], 'multi')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/disable/by-query', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the enableFlowsByIds operation.
     * @callback module:api/FlowsApi~enableFlowsByIdsCallback
     * @param {String} error Error message, if any.
     * @param {module:model/BulkResponse} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Enable flows by their IDs.
     * @param {String} tenant 
     * @param {Array.<module:model/IdWithNamespace>} idWithNamespace A list of tuple flow ID and namespace as flow identifiers
     * @param {module:api/FlowsApi~enableFlowsByIdsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/BulkResponse}
     */
    enableFlowsByIds(tenant, idWithNamespace, callback) {
      let postBody = idWithNamespace;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling enableFlowsByIds");
      }
      // verify the required parameter 'idWithNamespace' is set
      if (idWithNamespace === undefined || idWithNamespace === null) {
        throw new Error("Missing the required parameter 'idWithNamespace' when calling enableFlowsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/enable/by-ids', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the enableFlowsByQuery operation.
     * @callback module:api/FlowsApi~enableFlowsByQueryCallback
     * @param {String} error Error message, if any.
     * @param {module:model/BulkResponse} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Enable flows returned by the query parameters.
     * @param {String} tenant 
     * @param {module:model/DeleteExecutionsByQueryRequest} deleteExecutionsByQueryRequest 
     * @param {Object} opts Optional parameters
     * @param {String} [q] A string filter
     * @param {Array.<module:model/FlowScope>} [scope] The scope of the flows to include
     * @param {String} [namespace] A namespace filter prefix
     * @param {Array.<String>} [labels] A labels filter as a list of 'key:value'
     * @param {module:api/FlowsApi~enableFlowsByQueryCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/BulkResponse}
     */
    enableFlowsByQuery(tenant, deleteExecutionsByQueryRequest, opts, callback) {
      opts = opts || {};
      let postBody = deleteExecutionsByQueryRequest;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling enableFlowsByQuery");
      }
      // verify the required parameter 'deleteExecutionsByQueryRequest' is set
      if (deleteExecutionsByQueryRequest === undefined || deleteExecutionsByQueryRequest === null) {
        throw new Error("Missing the required parameter 'deleteExecutionsByQueryRequest' when calling enableFlowsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'q': opts['q'],
        'scope': this.apiClient.buildCollectionParam(opts['scope'], 'csv'),
        'namespace': opts['namespace'],
        'labels': this.apiClient.buildCollectionParam(opts['labels'], 'multi')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = BulkResponse;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/enable/by-query', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the exportFlowsByIds operation.
     * @callback module:api/FlowsApi~exportFlowsByIdsCallback
     * @param {String} error Error message, if any.
     * @param {Blob} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Export flows as a ZIP archive of yaml sources.
     * @param {String} tenant 
     * @param {Array.<module:model/IdWithNamespace>} idWithNamespace A list of tuple flow ID and namespace as flow identifiers
     * @param {module:api/FlowsApi~exportFlowsByIdsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Blob}
     */
    exportFlowsByIds(tenant, idWithNamespace, callback) {
      let postBody = idWithNamespace;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling exportFlowsByIds");
      }
      // verify the required parameter 'idWithNamespace' is set
      if (idWithNamespace === undefined || idWithNamespace === null) {
        throw new Error("Missing the required parameter 'idWithNamespace' when calling exportFlowsByIds");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/octet-stream'];
      let returnType = 'Blob';
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/export/by-ids', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the exportFlowsByQuery operation.
     * @callback module:api/FlowsApi~exportFlowsByQueryCallback
     * @param {String} error Error message, if any.
     * @param {Blob} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Export flows as a ZIP archive of yaml sources.
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/QueryFilter>} [filters] Filters
     * @param {String} [q] A string filter
     * @param {Array.<module:model/FlowScope>} [scope] The scope of the flows to include
     * @param {String} [namespace] A namespace filter prefix
     * @param {Array.<String>} [labels] A labels filter as a list of 'key:value'
     * @param {module:api/FlowsApi~exportFlowsByQueryCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Blob}
     */
    exportFlowsByQuery(tenant, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling exportFlowsByQuery");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv'),
        'q': opts['q'],
        'scope': this.apiClient.buildCollectionParam(opts['scope'], 'csv'),
        'namespace': opts['namespace'],
        'labels': this.apiClient.buildCollectionParam(opts['labels'], 'multi')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/octet-stream'];
      let returnType = 'Blob';
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/export/by-query', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the generateFlowGraph operation.
     * @callback module:api/FlowsApi~generateFlowGraphCallback
     * @param {String} error Error message, if any.
     * @param {module:model/FlowGraph} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Generate a graph for a flow
     * @param {String} namespace The flow namespace
     * @param {String} id The flow id
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Number} [revision] The flow revision
     * @param {Array.<String>} [subflows] The subflow tasks to display
     * @param {module:api/FlowsApi~generateFlowGraphCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/FlowGraph}
     */
    generateFlowGraph(namespace, id, tenant, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling generateFlowGraph");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling generateFlowGraph");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling generateFlowGraph");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'tenant': tenant
      };
      let queryParams = {
        'revision': opts['revision'],
        'subflows': this.apiClient.buildCollectionParam(opts['subflows'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = FlowGraph;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}/{id}/graph', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the generateFlowGraphFromSource operation.
     * @callback module:api/FlowsApi~generateFlowGraphFromSourceCallback
     * @param {String} error Error message, if any.
     * @param {module:model/FlowGraph} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Generate a graph for a flow source
     * @param {String} tenant 
     * @param {String} body The flow source code
     * @param {Object} opts Optional parameters
     * @param {Array.<String>} [subflows] The subflow tasks to display
     * @param {module:api/FlowsApi~generateFlowGraphFromSourceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/FlowGraph}
     */
    generateFlowGraphFromSource(tenant, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling generateFlowGraphFromSource");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling generateFlowGraphFromSource");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'subflows': this.apiClient.buildCollectionParam(opts['subflows'], 'csv')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/x-yaml'];
      let accepts = ['application/json'];
      let returnType = FlowGraph;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/graph', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getFlow operation.
     * @callback module:api/FlowsApi~getFlowCallback
     * @param {String} error Error message, if any.
     * @param {Object} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get a flow
     * @param {String} namespace The flow namespace
     * @param {String} id The flow id
     * @param {Boolean} source Include the source code
     * @param {Boolean} allowDeleted Get flow even if deleted
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Number} [revision] Get latest revision by default
     * @param {module:api/FlowsApi~getFlowCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Object}
     */
    getFlow(namespace, id, source, allowDeleted, tenant, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling getFlow");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getFlow");
      }
      // verify the required parameter 'source' is set
      if (source === undefined || source === null) {
        throw new Error("Missing the required parameter 'source' when calling getFlow");
      }
      // verify the required parameter 'allowDeleted' is set
      if (allowDeleted === undefined || allowDeleted === null) {
        throw new Error("Missing the required parameter 'allowDeleted' when calling getFlow");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getFlow");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'tenant': tenant
      };
      let queryParams = {
        'source': source,
        'revision': opts['revision'],
        'allowDeleted': allowDeleted
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getFlowDependencies operation.
     * @callback module:api/FlowsApi~getFlowDependenciesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/FlowTopologyGraph} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get flow dependencies
     * @param {String} namespace The flow namespace
     * @param {String} id The flow id
     * @param {Boolean} destinationOnly If true, list only destination dependencies, otherwise list also source dependencies
     * @param {Boolean} expandAll If true, expand all dependencies recursively
     * @param {String} tenant 
     * @param {module:api/FlowsApi~getFlowDependenciesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/FlowTopologyGraph}
     */
    getFlowDependencies(namespace, id, destinationOnly, expandAll, tenant, callback) {
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling getFlowDependencies");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getFlowDependencies");
      }
      // verify the required parameter 'destinationOnly' is set
      if (destinationOnly === undefined || destinationOnly === null) {
        throw new Error("Missing the required parameter 'destinationOnly' when calling getFlowDependencies");
      }
      // verify the required parameter 'expandAll' is set
      if (expandAll === undefined || expandAll === null) {
        throw new Error("Missing the required parameter 'expandAll' when calling getFlowDependencies");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getFlowDependencies");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'tenant': tenant
      };
      let queryParams = {
        'destinationOnly': destinationOnly,
        'expandAll': expandAll
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = FlowTopologyGraph;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}/{id}/dependencies', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getFlowDependenciesFromNamespace operation.
     * @callback module:api/FlowsApi~getFlowDependenciesFromNamespaceCallback
     * @param {String} error Error message, if any.
     * @param {module:model/FlowTopologyGraph} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Retrieve flow dependencies
     * @param {String} namespace The flow namespace
     * @param {Boolean} destinationOnly if true, list only destination dependencies, otherwise list also source dependencies
     * @param {String} tenant 
     * @param {module:api/FlowsApi~getFlowDependenciesFromNamespaceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/FlowTopologyGraph}
     */
    getFlowDependenciesFromNamespace(namespace, destinationOnly, tenant, callback) {
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling getFlowDependenciesFromNamespace");
      }
      // verify the required parameter 'destinationOnly' is set
      if (destinationOnly === undefined || destinationOnly === null) {
        throw new Error("Missing the required parameter 'destinationOnly' when calling getFlowDependenciesFromNamespace");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getFlowDependenciesFromNamespace");
      }

      let pathParams = {
        'namespace': namespace,
        'tenant': tenant
      };
      let queryParams = {
        'destinationOnly': destinationOnly
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = FlowTopologyGraph;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/namespaces/{namespace}/dependencies', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getTaskFromFlow operation.
     * @callback module:api/FlowsApi~getTaskFromFlowCallback
     * @param {String} error Error message, if any.
     * @param {module:model/Task} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get a flow task
     * @param {String} namespace The flow namespace
     * @param {String} id The flow id
     * @param {String} taskId The task id
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Number} [revision] The flow revision
     * @param {module:api/FlowsApi~getTaskFromFlowCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/Task}
     */
    getTaskFromFlow(namespace, id, taskId, tenant, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling getTaskFromFlow");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getTaskFromFlow");
      }
      // verify the required parameter 'taskId' is set
      if (taskId === undefined || taskId === null) {
        throw new Error("Missing the required parameter 'taskId' when calling getTaskFromFlow");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling getTaskFromFlow");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'taskId': taskId,
        'tenant': tenant
      };
      let queryParams = {
        'revision': opts['revision']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Task;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}/{id}/tasks/{taskId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the importFlows operation.
     * @callback module:api/FlowsApi~importFlowsCallback
     * @param {String} error Error message, if any.
     * @param {Array.<String>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     *     Import flows as a ZIP archive of yaml sources or a multi-objects YAML file.     When sending a Yaml that contains one or more flows, a list of index is returned.     When sending a ZIP archive, a list of files that couldn't be imported is returned. 
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {File} [fileUpload] The file to import, can be a ZIP archive or a multi-objects YAML file
     * @param {module:api/FlowsApi~importFlowsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<String>}
     */
    importFlows(tenant, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling importFlows");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
        'fileUpload': opts['fileUpload']
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['multipart/form-data'];
      let accepts = ['application/json'];
      let returnType = ['String'];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/import', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listDistinctNamespaces operation.
     * @callback module:api/FlowsApi~listDistinctNamespacesCallback
     * @param {String} error Error message, if any.
     * @param {Array.<String>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * List all distinct namespaces
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {String} [q] A string filter
     * @param {module:api/FlowsApi~listDistinctNamespacesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<String>}
     */
    listDistinctNamespaces(tenant, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling listDistinctNamespaces");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'q': opts['q']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ['String'];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/distinct-namespaces', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listFlowRevisions operation.
     * @callback module:api/FlowsApi~listFlowRevisionsCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/FlowWithSource>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get revisions for a flow
     * @param {String} namespace The flow namespace
     * @param {String} id The flow id
     * @param {String} tenant 
     * @param {module:api/FlowsApi~listFlowRevisionsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/FlowWithSource>}
     */
    listFlowRevisions(namespace, id, tenant, callback) {
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listFlowRevisions");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling listFlowRevisions");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling listFlowRevisions");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [FlowWithSource];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}/{id}/revisions', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the listFlowsByNamespace operation.
     * @callback module:api/FlowsApi~listFlowsByNamespaceCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/Flow>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Retrieve all flows from a given namespace
     * @param {String} namespace Namespace to filter flows
     * @param {String} tenant 
     * @param {module:api/FlowsApi~listFlowsByNamespaceCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/Flow>}
     */
    listFlowsByNamespace(namespace, tenant, callback) {
      let postBody = null;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling listFlowsByNamespace");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling listFlowsByNamespace");
      }

      let pathParams = {
        'namespace': namespace,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Flow];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the searchFlows operation.
     * @callback module:api/FlowsApi~searchFlowsCallback
     * @param {String} error Error message, if any.
     * @param {module:model/PagedResultsFlow} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Search for flows
     * @param {Number} page The current page
     * @param {Number} size The current page size
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<String>} [sort] The sort of current page
     * @param {Array.<module:model/QueryFilter>} [filters] Filters
     * @param {String} [q] A string filter
     * @param {Array.<module:model/FlowScope>} [scope] The scope of the flows to include
     * @param {String} [namespace] A namespace filter prefix
     * @param {Array.<String>} [labels] A labels filter as a list of 'key:value'
     * @param {module:api/FlowsApi~searchFlowsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/PagedResultsFlow}
     */
    searchFlows(page, size, tenant, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'page' is set
      if (page === undefined || page === null) {
        throw new Error("Missing the required parameter 'page' when calling searchFlows");
      }
      // verify the required parameter 'size' is set
      if (size === undefined || size === null) {
        throw new Error("Missing the required parameter 'size' when calling searchFlows");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling searchFlows");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'page': page,
        'size': size,
        'sort': this.apiClient.buildCollectionParam(opts['sort'], 'csv'),
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'csv'),
        'q': opts['q'],
        'scope': this.apiClient.buildCollectionParam(opts['scope'], 'csv'),
        'namespace': opts['namespace'],
        'labels': this.apiClient.buildCollectionParam(opts['labels'], 'multi')
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = PagedResultsFlow;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/search', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the searchFlowsBySourceCode operation.
     * @callback module:api/FlowsApi~searchFlowsBySourceCodeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/PagedResultsSearchResultFlow} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Search for flows source code
     * @param {Number} page The current page
     * @param {Number} size The current page size
     * @param {String} tenant 
     * @param {Object} opts Optional parameters
     * @param {Array.<String>} [sort] The sort of current page
     * @param {String} [q] A string filter
     * @param {String} [namespace] A namespace filter prefix
     * @param {module:api/FlowsApi~searchFlowsBySourceCodeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/PagedResultsSearchResultFlow}
     */
    searchFlowsBySourceCode(page, size, tenant, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'page' is set
      if (page === undefined || page === null) {
        throw new Error("Missing the required parameter 'page' when calling searchFlowsBySourceCode");
      }
      // verify the required parameter 'size' is set
      if (size === undefined || size === null) {
        throw new Error("Missing the required parameter 'size' when calling searchFlowsBySourceCode");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling searchFlowsBySourceCode");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'page': page,
        'size': size,
        'sort': this.apiClient.buildCollectionParam(opts['sort'], 'csv'),
        'q': opts['q'],
        'namespace': opts['namespace']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = PagedResultsSearchResultFlow;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/source', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the updateFlow operation.
     * @callback module:api/FlowsApi~updateFlowCallback
     * @param {String} error Error message, if any.
     * @param {module:model/UpdateFlow200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Update a flow
     * @param {String} id The flow id
     * @param {String} namespace The flow namespace
     * @param {String} tenant 
     * @param {String} body The flow source code
     * @param {module:api/FlowsApi~updateFlowCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/UpdateFlow200Response}
     */
    updateFlow(id, namespace, tenant, body, callback) {
      let postBody = body;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateFlow");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling updateFlow");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling updateFlow");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling updateFlow");
      }

      let pathParams = {
        'id': id,
        'namespace': namespace,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/x-yaml'];
      let accepts = ['application/json'];
      let returnType = UpdateFlow200Response;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}/{id}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the updateFlowsInNamespaceFromJson operation.
     * @callback module:api/FlowsApi~updateFlowsInNamespaceFromJsonCallback
     * @param {String} error Error message, if any.
     * @param {module:model/UpdateFlowsInNamespaceFromJson200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Update a complete namespace from json object
     * All flow will be created / updated for this namespace. Flow that already created but not in `flows` will be deleted if the query delete is `true`
     * @param {Boolean} _delete If missing flow should be deleted
     * @param {String} namespace The flow namespace
     * @param {String} tenant 
     * @param {Array.<module:model/Flow>} flow A list of flows
     * @param {module:api/FlowsApi~updateFlowsInNamespaceFromJsonCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/UpdateFlowsInNamespaceFromJson200Response}
     */
    updateFlowsInNamespaceFromJson(_delete, namespace, tenant, flow, callback) {
      let postBody = flow;
      // verify the required parameter '_delete' is set
      if (_delete === undefined || _delete === null) {
        throw new Error("Missing the required parameter '_delete' when calling updateFlowsInNamespaceFromJson");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling updateFlowsInNamespaceFromJson");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling updateFlowsInNamespaceFromJson");
      }
      // verify the required parameter 'flow' is set
      if (flow === undefined || flow === null) {
        throw new Error("Missing the required parameter 'flow' when calling updateFlowsInNamespaceFromJson");
      }

      let pathParams = {
        'namespace': namespace,
        'tenant': tenant
      };
      let queryParams = {
        'delete': _delete
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json', 'application/x-yaml'];
      let accepts = ['application/json'];
      let returnType = UpdateFlowsInNamespaceFromJson200Response;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the updateTask operation.
     * @callback module:api/FlowsApi~updateTaskCallback
     * @param {String} error Error message, if any.
     * @param {module:model/Flow} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Update a single task on a flow
     * @param {String} namespace The flow namespace
     * @param {String} id The flow id
     * @param {String} taskId The task id
     * @param {String} tenant 
     * @param {module:model/Task} task The task
     * @param {module:api/FlowsApi~updateTaskCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/Flow}
     */
    updateTask(namespace, id, taskId, tenant, task, callback) {
      let postBody = task;
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling updateTask");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateTask");
      }
      // verify the required parameter 'taskId' is set
      if (taskId === undefined || taskId === null) {
        throw new Error("Missing the required parameter 'taskId' when calling updateTask");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling updateTask");
      }
      // verify the required parameter 'task' is set
      if (task === undefined || task === null) {
        throw new Error("Missing the required parameter 'task' when calling updateTask");
      }

      let pathParams = {
        'namespace': namespace,
        'id': id,
        'taskId': taskId,
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = Flow;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/{namespace}/{id}/{taskId}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the validateFlows operation.
     * @callback module:api/FlowsApi~validateFlowsCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/ValidateConstraintViolation>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Validate a list of flows
     * @param {String} tenant 
     * @param {String} body A list of flows source code in a single string
     * @param {module:api/FlowsApi~validateFlowsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/ValidateConstraintViolation>}
     */
    validateFlows(tenant, body, callback) {
      let postBody = body;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling validateFlows");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling validateFlows");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/x-yaml'];
      let accepts = ['application/json'];
      let returnType = [ValidateConstraintViolation];
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/validate', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the validateTask operation.
     * @callback module:api/FlowsApi~validateTaskCallback
     * @param {String} error Error message, if any.
     * @param {module:model/ValidateConstraintViolation} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Validate a task
     * @param {module:model/FlowControllerTaskValidationType} section The type of task
     * @param {String} tenant 
     * @param {String} body A task definition that can be from tasks or triggers
     * @param {module:api/FlowsApi~validateTaskCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/ValidateConstraintViolation}
     */
    validateTask(section, tenant, body, callback) {
      let postBody = body;
      // verify the required parameter 'section' is set
      if (section === undefined || section === null) {
        throw new Error("Missing the required parameter 'section' when calling validateTask");
      }
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling validateTask");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling validateTask");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
        'section': section
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/x-yaml', 'application/json'];
      let accepts = ['application/json'];
      let returnType = ValidateConstraintViolation;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/validate/task', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the validateTrigger operation.
     * @callback module:api/FlowsApi~validateTriggerCallback
     * @param {String} error Error message, if any.
     * @param {module:model/ValidateConstraintViolation} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Validate trigger
     * @param {String} tenant 
     * @param {String} body The trigger
     * @param {module:api/FlowsApi~validateTriggerCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/ValidateConstraintViolation}
     */
    validateTrigger(tenant, body, callback) {
      let postBody = body;
      // verify the required parameter 'tenant' is set
      if (tenant === undefined || tenant === null) {
        throw new Error("Missing the required parameter 'tenant' when calling validateTrigger");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling validateTrigger");
      }

      let pathParams = {
        'tenant': tenant
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'bearerAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = ValidateConstraintViolation;
      return this.apiClient.callApi(
        '/api/v1/{tenant}/flows/validate/trigger', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }


}
