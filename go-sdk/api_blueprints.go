/*
Kestra EE

All API operations, except for Superadmin-only endpoints, require a tenant identifier in the HTTP path.<br/> Endpoints designated as Superadmin-only are not tenant-scoped.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package kestra_api_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// BlueprintsAPIService BlueprintsAPI service
type BlueprintsAPIService service

type ApiCreateInternalBlueprintsRequest struct {
	ctx                                           context.Context
	ApiService                                    *BlueprintsAPIService
	tenant                                        string
	blueprintControllerApiBlueprintItemWithSource *BlueprintControllerApiBlueprintItemWithSource
}

// The internal blueprint to create
func (r ApiCreateInternalBlueprintsRequest) BlueprintControllerApiBlueprintItemWithSource(blueprintControllerApiBlueprintItemWithSource BlueprintControllerApiBlueprintItemWithSource) ApiCreateInternalBlueprintsRequest {
	r.blueprintControllerApiBlueprintItemWithSource = &blueprintControllerApiBlueprintItemWithSource
	return r
}

func (r ApiCreateInternalBlueprintsRequest) Execute() (*BlueprintControllerApiBlueprintItemWithSource, *http.Response, error) {
	return r.ApiService.CreateInternalBlueprintsExecute(r)
}

/*
CreateInternalBlueprints Create a new internal blueprint

Creates a new internal (custom) blueprint for the current tenant. Requires BLUEPRINT permission.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiCreateInternalBlueprintsRequest
*/
func (a *BlueprintsAPIService) CreateInternalBlueprints(ctx context.Context, tenant string) ApiCreateInternalBlueprintsRequest {
	return ApiCreateInternalBlueprintsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BlueprintControllerApiBlueprintItemWithSource
func (a *BlueprintsAPIService) CreateInternalBlueprintsExecute(r ApiCreateInternalBlueprintsRequest) (*BlueprintControllerApiBlueprintItemWithSource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BlueprintControllerApiBlueprintItemWithSource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueprintsAPIService.CreateInternalBlueprints")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/blueprints/custom"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blueprintControllerApiBlueprintItemWithSource == nil {
		return localVarReturnValue, nil, reportError("blueprintControllerApiBlueprintItemWithSource is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blueprintControllerApiBlueprintItemWithSource
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteInternalBlueprintsRequest struct {
	ctx        context.Context
	ApiService *BlueprintsAPIService
	id         string
	tenant     string
}

func (r ApiDeleteInternalBlueprintsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteInternalBlueprintsExecute(r)
}

/*
DeleteInternalBlueprints Delete an internal blueprint

Deletes an internal (custom) blueprint for the current tenant. Requires BLUEPRINT permission.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The internal blueprint id to delete
	@param tenant
	@return ApiDeleteInternalBlueprintsRequest
*/
func (a *BlueprintsAPIService) DeleteInternalBlueprints(ctx context.Context, id string, tenant string) ApiDeleteInternalBlueprintsRequest {
	return ApiDeleteInternalBlueprintsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		tenant:     tenant,
	}
}

// Execute executes the request
func (a *BlueprintsAPIService) DeleteInternalBlueprintsExecute(r ApiDeleteInternalBlueprintsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueprintsAPIService.DeleteInternalBlueprints")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/blueprints/custom/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetBlueprintRequest struct {
	ctx        context.Context
	ApiService *BlueprintsAPIService
	id         string
	kind       BlueprintControllerKind
	tenant     string
}

func (r ApiGetBlueprintRequest) Execute() (*BlueprintControllerApiBlueprintItemWithSource, *http.Response, error) {
	return r.ApiService.GetBlueprintExecute(r)
}

/*
GetBlueprint Retrieve a blueprint

Retrieves details of a specific community blueprint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The blueprint id
	@param kind The blueprint kind
	@param tenant
	@return ApiGetBlueprintRequest
*/
func (a *BlueprintsAPIService) GetBlueprint(ctx context.Context, id string, kind BlueprintControllerKind, tenant string) ApiGetBlueprintRequest {
	return ApiGetBlueprintRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		kind:       kind,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BlueprintControllerApiBlueprintItemWithSource
func (a *BlueprintsAPIService) GetBlueprintExecute(r ApiGetBlueprintRequest) (*BlueprintControllerApiBlueprintItemWithSource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BlueprintControllerApiBlueprintItemWithSource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueprintsAPIService.GetBlueprint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/blueprints/community/{kind}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"kind"+"}", url.PathEscape(parameterValueToString(r.kind, "kind")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlueprintGraphRequest struct {
	ctx        context.Context
	ApiService *BlueprintsAPIService
	id         string
	kind       BlueprintControllerKind
	tenant     string
}

func (r ApiGetBlueprintGraphRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetBlueprintGraphExecute(r)
}

/*
GetBlueprintGraph Retrieve a blueprint graph

Retrieves the topology graph representation of a specific community blueprint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The blueprint id
	@param kind The blueprint kind
	@param tenant
	@return ApiGetBlueprintGraphRequest
*/
func (a *BlueprintsAPIService) GetBlueprintGraph(ctx context.Context, id string, kind BlueprintControllerKind, tenant string) ApiGetBlueprintGraphRequest {
	return ApiGetBlueprintGraphRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		kind:       kind,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *BlueprintsAPIService) GetBlueprintGraphExecute(r ApiGetBlueprintGraphRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueprintsAPIService.GetBlueprintGraph")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/blueprints/community/{kind}/{id}/graph"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"kind"+"}", url.PathEscape(parameterValueToString(r.kind, "kind")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlueprintSourceRequest struct {
	ctx        context.Context
	ApiService *BlueprintsAPIService
	id         string
	kind       BlueprintControllerKind
	tenant     string
}

func (r ApiGetBlueprintSourceRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetBlueprintSourceExecute(r)
}

/*
GetBlueprintSource Retrieve a blueprint source code

Retrieves the YAML source code for a specific community blueprint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The blueprint id
	@param kind The blueprint kind
	@param tenant
	@return ApiGetBlueprintSourceRequest
*/
func (a *BlueprintsAPIService) GetBlueprintSource(ctx context.Context, id string, kind BlueprintControllerKind, tenant string) ApiGetBlueprintSourceRequest {
	return ApiGetBlueprintSourceRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		kind:       kind,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return string
func (a *BlueprintsAPIService) GetBlueprintSourceExecute(r ApiGetBlueprintSourceRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueprintsAPIService.GetBlueprintSource")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/blueprints/community/{kind}/{id}/source"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"kind"+"}", url.PathEscape(parameterValueToString(r.kind, "kind")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInternalBlueprintRequest struct {
	ctx        context.Context
	ApiService *BlueprintsAPIService
	id         string
	tenant     string
}

func (r ApiInternalBlueprintRequest) Execute() (*BlueprintControllerApiBlueprintItemWithSource, *http.Response, error) {
	return r.ApiService.InternalBlueprintExecute(r)
}

/*
InternalBlueprint Retrieve an internal blueprint

Retrieves details of a specific internal (custom) blueprint. Requires BLUEPRINT permission.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The blueprint id
	@param tenant
	@return ApiInternalBlueprintRequest
*/
func (a *BlueprintsAPIService) InternalBlueprint(ctx context.Context, id string, tenant string) ApiInternalBlueprintRequest {
	return ApiInternalBlueprintRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BlueprintControllerApiBlueprintItemWithSource
func (a *BlueprintsAPIService) InternalBlueprintExecute(r ApiInternalBlueprintRequest) (*BlueprintControllerApiBlueprintItemWithSource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BlueprintControllerApiBlueprintItemWithSource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueprintsAPIService.InternalBlueprint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/blueprints/custom/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInternalBlueprintFlowRequest struct {
	ctx        context.Context
	ApiService *BlueprintsAPIService
	id         string
	tenant     string
}

func (r ApiInternalBlueprintFlowRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.InternalBlueprintFlowExecute(r)
}

/*
InternalBlueprintFlow Retrieve an internal blueprint source code

Retrieves the YAML source code for a specific internal (custom) blueprint. Requires BLUEPRINT permission.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The blueprint id
	@param tenant
	@return ApiInternalBlueprintFlowRequest
*/
func (a *BlueprintsAPIService) InternalBlueprintFlow(ctx context.Context, id string, tenant string) ApiInternalBlueprintFlowRequest {
	return ApiInternalBlueprintFlowRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return string
func (a *BlueprintsAPIService) InternalBlueprintFlowExecute(r ApiInternalBlueprintFlowRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueprintsAPIService.InternalBlueprintFlow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/blueprints/custom/{id}/source"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchBlueprintsRequest struct {
	ctx        context.Context
	ApiService *BlueprintsAPIService
	page       *int32
	size       *int32
	kind       BlueprintControllerKind
	tenant     string
	q          *string
	sort       *string
	tags       *[]string
}

// The current page
func (r ApiSearchBlueprintsRequest) Page(page int32) ApiSearchBlueprintsRequest {
	r.page = &page
	return r
}

// The current page size
func (r ApiSearchBlueprintsRequest) Size(size int32) ApiSearchBlueprintsRequest {
	r.size = &size
	return r
}

// A string filter
func (r ApiSearchBlueprintsRequest) Q(q string) ApiSearchBlueprintsRequest {
	r.q = &q
	return r
}

// The sort of current page
func (r ApiSearchBlueprintsRequest) Sort(sort string) ApiSearchBlueprintsRequest {
	r.sort = &sort
	return r
}

// A tags filter
func (r ApiSearchBlueprintsRequest) Tags(tags []string) ApiSearchBlueprintsRequest {
	r.tags = &tags
	return r
}

func (r ApiSearchBlueprintsRequest) Execute() (*PagedResultsBlueprintControllerApiBlueprintItem, *http.Response, error) {
	return r.ApiService.SearchBlueprintsExecute(r)
}

/*
SearchBlueprints List all blueprints

Lists all community blueprints of the specified kind. Community blueprints are shared and versioned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param kind The blueprint kind
	@param tenant
	@return ApiSearchBlueprintsRequest
*/
func (a *BlueprintsAPIService) SearchBlueprints(ctx context.Context, kind BlueprintControllerKind, tenant string) ApiSearchBlueprintsRequest {
	return ApiSearchBlueprintsRequest{
		ApiService: a,
		ctx:        ctx,
		kind:       kind,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return PagedResultsBlueprintControllerApiBlueprintItem
func (a *BlueprintsAPIService) SearchBlueprintsExecute(r ApiSearchBlueprintsRequest) (*PagedResultsBlueprintControllerApiBlueprintItem, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PagedResultsBlueprintControllerApiBlueprintItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueprintsAPIService.SearchBlueprints")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/blueprints/community/{kind}"
	localVarPath = strings.Replace(localVarPath, "{"+"kind"+"}", url.PathEscape(parameterValueToString(r.kind, "kind")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if *r.page < 1 {
		return localVarReturnValue, nil, reportError("page must be greater than 1")
	}
	if r.size == nil {
		return localVarReturnValue, nil, reportError("size is required and must be specified")
	}
	if *r.size < 1 {
		return localVarReturnValue, nil, reportError("size must be greater than 1")
	}

	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "form", "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchInternalBlueprintsRequest struct {
	ctx        context.Context
	ApiService *BlueprintsAPIService
	page       *int32
	size       *int32
	tenant     string
	q          *string
	sort       *string
	tags       *[]string
}

// The current page
func (r ApiSearchInternalBlueprintsRequest) Page(page int32) ApiSearchInternalBlueprintsRequest {
	r.page = &page
	return r
}

// The current page size
func (r ApiSearchInternalBlueprintsRequest) Size(size int32) ApiSearchInternalBlueprintsRequest {
	r.size = &size
	return r
}

// A string filter
func (r ApiSearchInternalBlueprintsRequest) Q(q string) ApiSearchInternalBlueprintsRequest {
	r.q = &q
	return r
}

// The sort of current page
func (r ApiSearchInternalBlueprintsRequest) Sort(sort string) ApiSearchInternalBlueprintsRequest {
	r.sort = &sort
	return r
}

// A tags filter
func (r ApiSearchInternalBlueprintsRequest) Tags(tags []string) ApiSearchInternalBlueprintsRequest {
	r.tags = &tags
	return r
}

func (r ApiSearchInternalBlueprintsRequest) Execute() (*PagedResultsBlueprint, *http.Response, error) {
	return r.ApiService.SearchInternalBlueprintsExecute(r)
}

/*
SearchInternalBlueprints List all internal blueprints

Lists all internal (custom) blueprints for the current tenant. Requires BLUEPRINT permission.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiSearchInternalBlueprintsRequest
*/
func (a *BlueprintsAPIService) SearchInternalBlueprints(ctx context.Context, tenant string) ApiSearchInternalBlueprintsRequest {
	return ApiSearchInternalBlueprintsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return PagedResultsBlueprint
func (a *BlueprintsAPIService) SearchInternalBlueprintsExecute(r ApiSearchInternalBlueprintsRequest) (*PagedResultsBlueprint, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PagedResultsBlueprint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueprintsAPIService.SearchInternalBlueprints")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/blueprints/custom"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if r.size == nil {
		return localVarReturnValue, nil, reportError("size is required and must be specified")
	}

	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "form", "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateInternalBlueprintsRequest struct {
	ctx                                           context.Context
	ApiService                                    *BlueprintsAPIService
	id                                            string
	tenant                                        string
	blueprintControllerApiBlueprintItemWithSource *BlueprintControllerApiBlueprintItemWithSource
}

// The new internal blueprint for update
func (r ApiUpdateInternalBlueprintsRequest) BlueprintControllerApiBlueprintItemWithSource(blueprintControllerApiBlueprintItemWithSource BlueprintControllerApiBlueprintItemWithSource) ApiUpdateInternalBlueprintsRequest {
	r.blueprintControllerApiBlueprintItemWithSource = &blueprintControllerApiBlueprintItemWithSource
	return r
}

func (r ApiUpdateInternalBlueprintsRequest) Execute() (*BlueprintWithFlow, *http.Response, error) {
	return r.ApiService.UpdateInternalBlueprintsExecute(r)
}

/*
UpdateInternalBlueprints Update an internal blueprint

Updates an existing internal (custom) blueprint for the current tenant. Requires BLUEPRINT permission.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the internal blueprint to update
	@param tenant
	@return ApiUpdateInternalBlueprintsRequest
*/
func (a *BlueprintsAPIService) UpdateInternalBlueprints(ctx context.Context, id string, tenant string) ApiUpdateInternalBlueprintsRequest {
	return ApiUpdateInternalBlueprintsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BlueprintWithFlow
func (a *BlueprintsAPIService) UpdateInternalBlueprintsExecute(r ApiUpdateInternalBlueprintsRequest) (*BlueprintWithFlow, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BlueprintWithFlow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueprintsAPIService.UpdateInternalBlueprints")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/blueprints/custom/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blueprintControllerApiBlueprintItemWithSource == nil {
		return localVarReturnValue, nil, reportError("blueprintControllerApiBlueprintItemWithSource is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blueprintControllerApiBlueprintItemWithSource
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
