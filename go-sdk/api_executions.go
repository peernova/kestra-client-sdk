/*
Kestra EE

All API operations, except for Superadmin-only endpoints, require a tenant identifier in the HTTP path.<br/> Endpoints designated as Superadmin-only are not tenant-scoped.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package kestra_api_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"reflect"
	"strings"
	"time"
)

// ExecutionsAPIService ExecutionsAPI service
type ExecutionsAPIService service

type ApiCreateExecutionRequest struct {
	ctx          context.Context
	ApiService   *ExecutionsAPIService
	namespace    string
	id           string
	wait         *bool
	tenant       string
	labels       *[]string
	revision     *int32
	scheduleDate *time.Time
	breakpoints  *string
	kind         *ExecutionKind
}

// If the server will wait the end of the execution
func (r ApiCreateExecutionRequest) Wait(wait bool) ApiCreateExecutionRequest {
	r.wait = &wait
	return r
}

// The labels as a list of &#39;key:value&#39;
func (r ApiCreateExecutionRequest) Labels(labels []string) ApiCreateExecutionRequest {
	r.labels = &labels
	return r
}

// The flow revision or latest if null
func (r ApiCreateExecutionRequest) Revision(revision int32) ApiCreateExecutionRequest {
	r.revision = &revision
	return r
}

// Schedule the flow on a specific date
func (r ApiCreateExecutionRequest) ScheduleDate(scheduleDate time.Time) ApiCreateExecutionRequest {
	r.scheduleDate = &scheduleDate
	return r
}

// Set a list of breakpoints at specific tasks &#39;id.value&#39;, separated by a coma.
func (r ApiCreateExecutionRequest) Breakpoints(breakpoints string) ApiCreateExecutionRequest {
	r.breakpoints = &breakpoints
	return r
}

// Specific execution kind
func (r ApiCreateExecutionRequest) Kind(kind ExecutionKind) ApiCreateExecutionRequest {
	r.kind = &kind
	return r
}

func (r ApiCreateExecutionRequest) Execute() ([]ExecutionControllerExecutionResponse, *http.Response, error) {
	return r.ApiService.CreateExecutionExecute(r)
}

/*
CreateExecution Create a new execution for a flow

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param namespace The flow namespace
	@param id The flow id
	@param tenant
	@return ApiCreateExecutionRequest
*/
func (a *ExecutionsAPIService) CreateExecution(ctx context.Context, namespace string, id string, tenant string) ApiCreateExecutionRequest {
	return ApiCreateExecutionRequest{
		ApiService: a,
		ctx:        ctx,
		namespace:  namespace,
		id:         id,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return []ExecutionControllerExecutionResponse
func (a *ExecutionsAPIService) CreateExecutionExecute(r ApiCreateExecutionRequest) ([]ExecutionControllerExecutionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ExecutionControllerExecutionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.CreateExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{namespace}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.wait == nil {
		return localVarReturnValue, nil, reportError("wait is required and must be specified")
	}

	if r.labels != nil {
		t := *r.labels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "labels", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "labels", t, "form", "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "wait", r.wait, "form", "")
	if r.revision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revision", r.revision, "form", "")
	}
	if r.scheduleDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduleDate", r.scheduleDate, "form", "")
	}
	if r.breakpoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakpoints", r.breakpoints, "form", "")
	}
	if r.kind != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "kind", r.kind, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteExecutionRequest struct {
	ctx           context.Context
	ApiService    *ExecutionsAPIService
	executionId   string
	deleteLogs    *bool
	deleteMetrics *bool
	deleteStorage *bool
	tenant        string
}

// Whether to delete execution logs
func (r ApiDeleteExecutionRequest) DeleteLogs(deleteLogs bool) ApiDeleteExecutionRequest {
	r.deleteLogs = &deleteLogs
	return r
}

// Whether to delete execution metrics
func (r ApiDeleteExecutionRequest) DeleteMetrics(deleteMetrics bool) ApiDeleteExecutionRequest {
	r.deleteMetrics = &deleteMetrics
	return r
}

// Whether to delete execution files in the internal storage
func (r ApiDeleteExecutionRequest) DeleteStorage(deleteStorage bool) ApiDeleteExecutionRequest {
	r.deleteStorage = &deleteStorage
	return r
}

func (r ApiDeleteExecutionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteExecutionExecute(r)
}

/*
DeleteExecution Delete an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiDeleteExecutionRequest
*/
func (a *ExecutionsAPIService) DeleteExecution(ctx context.Context, executionId string, tenant string) ApiDeleteExecutionRequest {
	return ApiDeleteExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
func (a *ExecutionsAPIService) DeleteExecutionExecute(r ApiDeleteExecutionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.DeleteExecution")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deleteLogs == nil {
		return nil, reportError("deleteLogs is required and must be specified")
	}
	if r.deleteMetrics == nil {
		return nil, reportError("deleteMetrics is required and must be specified")
	}
	if r.deleteStorage == nil {
		return nil, reportError("deleteStorage is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "deleteLogs", r.deleteLogs, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "deleteMetrics", r.deleteMetrics, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "deleteStorage", r.deleteStorage, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteExecutionsByIdsRequest struct {
	ctx                  context.Context
	ApiService           *ExecutionsAPIService
	deleteLogs           *bool
	deleteMetrics        *bool
	deleteStorage        *bool
	tenant               string
	requestBody          *[]string
	includeNonTerminated *bool
}

// Whether to delete execution logs
func (r ApiDeleteExecutionsByIdsRequest) DeleteLogs(deleteLogs bool) ApiDeleteExecutionsByIdsRequest {
	r.deleteLogs = &deleteLogs
	return r
}

// Whether to delete execution metrics
func (r ApiDeleteExecutionsByIdsRequest) DeleteMetrics(deleteMetrics bool) ApiDeleteExecutionsByIdsRequest {
	r.deleteMetrics = &deleteMetrics
	return r
}

// Whether to delete execution files in the internal storage
func (r ApiDeleteExecutionsByIdsRequest) DeleteStorage(deleteStorage bool) ApiDeleteExecutionsByIdsRequest {
	r.deleteStorage = &deleteStorage
	return r
}

// The execution id
func (r ApiDeleteExecutionsByIdsRequest) RequestBody(requestBody []string) ApiDeleteExecutionsByIdsRequest {
	r.requestBody = &requestBody
	return r
}

// Whether to delete non-terminated executions
func (r ApiDeleteExecutionsByIdsRequest) IncludeNonTerminated(includeNonTerminated bool) ApiDeleteExecutionsByIdsRequest {
	r.includeNonTerminated = &includeNonTerminated
	return r
}

func (r ApiDeleteExecutionsByIdsRequest) Execute() (*BulkResponse, *http.Response, error) {
	return r.ApiService.DeleteExecutionsByIdsExecute(r)
}

/*
DeleteExecutionsByIds Delete a list of executions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiDeleteExecutionsByIdsRequest
*/
func (a *ExecutionsAPIService) DeleteExecutionsByIds(ctx context.Context, tenant string) ApiDeleteExecutionsByIdsRequest {
	return ApiDeleteExecutionsByIdsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BulkResponse
func (a *ExecutionsAPIService) DeleteExecutionsByIdsExecute(r ApiDeleteExecutionsByIdsRequest) (*BulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.DeleteExecutionsByIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/by-ids"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deleteLogs == nil {
		return localVarReturnValue, nil, reportError("deleteLogs is required and must be specified")
	}
	if r.deleteMetrics == nil {
		return localVarReturnValue, nil, reportError("deleteMetrics is required and must be specified")
	}
	if r.deleteStorage == nil {
		return localVarReturnValue, nil, reportError("deleteStorage is required and must be specified")
	}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	if r.includeNonTerminated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeNonTerminated", r.includeNonTerminated, "form", "")
	} else {
		var defaultValue bool = false
		r.includeNonTerminated = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "deleteLogs", r.deleteLogs, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "deleteMetrics", r.deleteMetrics, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "deleteStorage", r.deleteStorage, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v BulkErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteExecutionsByQueryRequest struct {
	ctx                            context.Context
	ApiService                     *ExecutionsAPIService
	deleteLogs                     *bool
	deleteMetrics                  *bool
	deleteStorage                  *bool
	tenant                         string
	deleteExecutionsByQueryRequest *DeleteExecutionsByQueryRequest
	q                              *string
	scope                          *[]FlowScope
	namespace                      *string
	flowId                         *string
	startDate                      *time.Time
	endDate                        *time.Time
	timeRange                      *string
	state                          *[]StateType
	labels                         *[]string
	triggerExecutionId             *string
	childFilter                    *ExecutionRepositoryInterfaceChildFilter
	includeNonTerminated           *bool
}

// Whether to delete execution logs
func (r ApiDeleteExecutionsByQueryRequest) DeleteLogs(deleteLogs bool) ApiDeleteExecutionsByQueryRequest {
	r.deleteLogs = &deleteLogs
	return r
}

// Whether to delete execution metrics
func (r ApiDeleteExecutionsByQueryRequest) DeleteMetrics(deleteMetrics bool) ApiDeleteExecutionsByQueryRequest {
	r.deleteMetrics = &deleteMetrics
	return r
}

// Whether to delete execution files in the internal storage
func (r ApiDeleteExecutionsByQueryRequest) DeleteStorage(deleteStorage bool) ApiDeleteExecutionsByQueryRequest {
	r.deleteStorage = &deleteStorage
	return r
}

func (r ApiDeleteExecutionsByQueryRequest) DeleteExecutionsByQueryRequest(deleteExecutionsByQueryRequest DeleteExecutionsByQueryRequest) ApiDeleteExecutionsByQueryRequest {
	r.deleteExecutionsByQueryRequest = &deleteExecutionsByQueryRequest
	return r
}

// A string filter
func (r ApiDeleteExecutionsByQueryRequest) Q(q string) ApiDeleteExecutionsByQueryRequest {
	r.q = &q
	return r
}

// The scope of the executions to include
func (r ApiDeleteExecutionsByQueryRequest) Scope(scope []FlowScope) ApiDeleteExecutionsByQueryRequest {
	r.scope = &scope
	return r
}

// A namespace filter prefix
func (r ApiDeleteExecutionsByQueryRequest) Namespace(namespace string) ApiDeleteExecutionsByQueryRequest {
	r.namespace = &namespace
	return r
}

// A flow id filter
func (r ApiDeleteExecutionsByQueryRequest) FlowId(flowId string) ApiDeleteExecutionsByQueryRequest {
	r.flowId = &flowId
	return r
}

// The start datetime
func (r ApiDeleteExecutionsByQueryRequest) StartDate(startDate time.Time) ApiDeleteExecutionsByQueryRequest {
	r.startDate = &startDate
	return r
}

// The end datetime
func (r ApiDeleteExecutionsByQueryRequest) EndDate(endDate time.Time) ApiDeleteExecutionsByQueryRequest {
	r.endDate = &endDate
	return r
}

// A time range filter relative to the current time
func (r ApiDeleteExecutionsByQueryRequest) TimeRange(timeRange string) ApiDeleteExecutionsByQueryRequest {
	r.timeRange = &timeRange
	return r
}

// A state filter
func (r ApiDeleteExecutionsByQueryRequest) State(state []StateType) ApiDeleteExecutionsByQueryRequest {
	r.state = &state
	return r
}

// A labels filter as a list of &#39;key:value&#39;
func (r ApiDeleteExecutionsByQueryRequest) Labels(labels []string) ApiDeleteExecutionsByQueryRequest {
	r.labels = &labels
	return r
}

// The trigger execution id
func (r ApiDeleteExecutionsByQueryRequest) TriggerExecutionId(triggerExecutionId string) ApiDeleteExecutionsByQueryRequest {
	r.triggerExecutionId = &triggerExecutionId
	return r
}

// A execution child filter
func (r ApiDeleteExecutionsByQueryRequest) ChildFilter(childFilter ExecutionRepositoryInterfaceChildFilter) ApiDeleteExecutionsByQueryRequest {
	r.childFilter = &childFilter
	return r
}

// Whether to delete non-terminated executions
func (r ApiDeleteExecutionsByQueryRequest) IncludeNonTerminated(includeNonTerminated bool) ApiDeleteExecutionsByQueryRequest {
	r.includeNonTerminated = &includeNonTerminated
	return r
}

func (r ApiDeleteExecutionsByQueryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteExecutionsByQueryExecute(r)
}

/*
DeleteExecutionsByQuery Delete executions filter by query parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiDeleteExecutionsByQueryRequest
*/
func (a *ExecutionsAPIService) DeleteExecutionsByQuery(ctx context.Context, tenant string) ApiDeleteExecutionsByQueryRequest {
	return ApiDeleteExecutionsByQueryRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ExecutionsAPIService) DeleteExecutionsByQueryExecute(r ApiDeleteExecutionsByQueryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.DeleteExecutionsByQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/by-query"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deleteLogs == nil {
		return localVarReturnValue, nil, reportError("deleteLogs is required and must be specified")
	}
	if r.deleteMetrics == nil {
		return localVarReturnValue, nil, reportError("deleteMetrics is required and must be specified")
	}
	if r.deleteStorage == nil {
		return localVarReturnValue, nil, reportError("deleteStorage is required and must be specified")
	}
	if r.deleteExecutionsByQueryRequest == nil {
		return localVarReturnValue, nil, reportError("deleteExecutionsByQueryRequest is required and must be specified")
	}

	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "form", "csv")
	}
	if r.namespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "namespace", r.namespace, "form", "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.timeRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeRange", r.timeRange, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "csv")
	}
	if r.labels != nil {
		t := *r.labels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "labels", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "labels", t, "form", "multi")
		}
	}
	if r.triggerExecutionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "triggerExecutionId", r.triggerExecutionId, "form", "")
	}
	if r.childFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "childFilter", r.childFilter, "form", "")
	}
	if r.includeNonTerminated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeNonTerminated", r.includeNonTerminated, "form", "")
	} else {
		var defaultValue bool = false
		r.includeNonTerminated = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "deleteLogs", r.deleteLogs, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "deleteMetrics", r.deleteMetrics, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "deleteStorage", r.deleteStorage, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteExecutionsByQueryRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadFileFromExecutionRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	path        *string
	tenant      string
}

// The internal storage uri
func (r ApiDownloadFileFromExecutionRequest) Path(path string) ApiDownloadFileFromExecutionRequest {
	r.path = &path
	return r
}

func (r ApiDownloadFileFromExecutionRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.DownloadFileFromExecutionExecute(r)
}

/*
DownloadFileFromExecution Download file for an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiDownloadFileFromExecutionRequest
*/
func (a *ExecutionsAPIService) DownloadFileFromExecution(ctx context.Context, executionId string, tenant string) ApiDownloadFileFromExecutionRequest {
	return ApiDownloadFileFromExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *ExecutionsAPIService) DownloadFileFromExecutionExecute(r ApiDownloadFileFromExecutionRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.DownloadFileFromExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/file"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEvalTaskRunExpressionRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	taskRunId   string
	tenant      string
	body        *string
}

// The Pebble expression that should be evaluated
func (r ApiEvalTaskRunExpressionRequest) Body(body string) ApiEvalTaskRunExpressionRequest {
	r.body = &body
	return r
}

func (r ApiEvalTaskRunExpressionRequest) Execute() (*ExecutionControllerEvalResult, *http.Response, error) {
	return r.ApiService.EvalTaskRunExpressionExecute(r)
}

/*
EvalTaskRunExpression Evaluate a variable expression for this taskrun

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param taskRunId The taskrun id
	@param tenant
	@return ApiEvalTaskRunExpressionRequest
*/
func (a *ExecutionsAPIService) EvalTaskRunExpression(ctx context.Context, executionId string, taskRunId string, tenant string) ApiEvalTaskRunExpressionRequest {
	return ApiEvalTaskRunExpressionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		taskRunId:   taskRunId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return ExecutionControllerEvalResult
func (a *ExecutionsAPIService) EvalTaskRunExpressionExecute(r ApiEvalTaskRunExpressionRequest) (*ExecutionControllerEvalResult, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExecutionControllerEvalResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.EvalTaskRunExpression")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/eval/{taskRunId}"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"taskRunId"+"}", url.PathEscape(parameterValueToString(r.taskRunId, "taskRunId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFollowDependenciesExecutionsRequest struct {
	ctx             context.Context
	ApiService      *ExecutionsAPIService
	executionId     string
	destinationOnly *bool
	expandAll       *bool
	tenant          string
}

// If true, list only destination dependencies, otherwise list also source dependencies
func (r ApiFollowDependenciesExecutionsRequest) DestinationOnly(destinationOnly bool) ApiFollowDependenciesExecutionsRequest {
	r.destinationOnly = &destinationOnly
	return r
}

// If true, expand all dependencies recursively
func (r ApiFollowDependenciesExecutionsRequest) ExpandAll(expandAll bool) ApiFollowDependenciesExecutionsRequest {
	r.expandAll = &expandAll
	return r
}

func (r ApiFollowDependenciesExecutionsRequest) Execute() (*EventExecutionStatusEvent, *http.Response, error) {
	return r.ApiService.FollowDependenciesExecutionsExecute(r)
}

/*
FollowDependenciesExecutions Follow all execution dependencies executions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiFollowDependenciesExecutionsRequest
*/
func (a *ExecutionsAPIService) FollowDependenciesExecutions(ctx context.Context, executionId string, tenant string) ApiFollowDependenciesExecutionsRequest {
	return ApiFollowDependenciesExecutionsRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return EventExecutionStatusEvent
func (a *ExecutionsAPIService) FollowDependenciesExecutionsExecute(r ApiFollowDependenciesExecutionsRequest) (*EventExecutionStatusEvent, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EventExecutionStatusEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.FollowDependenciesExecutions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/follow-dependencies"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.destinationOnly == nil {
		return localVarReturnValue, nil, reportError("destinationOnly is required and must be specified")
	}
	if r.expandAll == nil {
		return localVarReturnValue, nil, reportError("expandAll is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "destinationOnly", r.destinationOnly, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "expandAll", r.expandAll, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/event-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFollowExecutionRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	tenant      string
}

func (r ApiFollowExecutionRequest) Execute() (*EventExecution, *http.Response, error) {
	return r.ApiService.FollowExecutionExecute(r)
}

/*
FollowExecution Follow an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiFollowExecutionRequest
*/
func (a *ExecutionsAPIService) FollowExecution(ctx context.Context, executionId string, tenant string) ApiFollowExecutionRequest {
	return ApiFollowExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return EventExecution
func (a *ExecutionsAPIService) FollowExecutionExecute(r ApiFollowExecutionRequest) (*EventExecution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EventExecution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.FollowExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/follow"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/event-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiForceRunByIdsRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	tenant      string
	requestBody *[]string
}

// The list of executions id
func (r ApiForceRunByIdsRequest) RequestBody(requestBody []string) ApiForceRunByIdsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiForceRunByIdsRequest) Execute() (*BulkResponse, *http.Response, error) {
	return r.ApiService.ForceRunByIdsExecute(r)
}

/*
ForceRunByIds Force run a list of executions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiForceRunByIdsRequest
*/
func (a *ExecutionsAPIService) ForceRunByIds(ctx context.Context, tenant string) ApiForceRunByIdsRequest {
	return ApiForceRunByIdsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BulkResponse
func (a *ExecutionsAPIService) ForceRunByIdsExecute(r ApiForceRunByIdsRequest) (*BulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ForceRunByIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/force-run/by-ids"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v BulkErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiForceRunExecutionRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	tenant      string
}

func (r ApiForceRunExecutionRequest) Execute() (*Execution, *http.Response, error) {
	return r.ApiService.ForceRunExecutionExecute(r)
}

/*
ForceRunExecution Force run an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiForceRunExecutionRequest
*/
func (a *ExecutionsAPIService) ForceRunExecution(ctx context.Context, executionId string, tenant string) ApiForceRunExecutionRequest {
	return ApiForceRunExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return Execution
func (a *ExecutionsAPIService) ForceRunExecutionExecute(r ApiForceRunExecutionRequest) (*Execution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Execution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ForceRunExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/force-run"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiForceRunExecutionsByQueryRequest struct {
	ctx                            context.Context
	ApiService                     *ExecutionsAPIService
	tenant                         string
	deleteExecutionsByQueryRequest *DeleteExecutionsByQueryRequest
	q                              *string
	scope                          *[]FlowScope
	namespace                      *string
	flowId                         *string
	startDate                      *time.Time
	endDate                        *time.Time
	timeRange                      *string
	state                          *[]StateType
	labels                         *[]string
	triggerExecutionId             *string
	childFilter                    *ExecutionRepositoryInterfaceChildFilter
}

func (r ApiForceRunExecutionsByQueryRequest) DeleteExecutionsByQueryRequest(deleteExecutionsByQueryRequest DeleteExecutionsByQueryRequest) ApiForceRunExecutionsByQueryRequest {
	r.deleteExecutionsByQueryRequest = &deleteExecutionsByQueryRequest
	return r
}

// A string filter
func (r ApiForceRunExecutionsByQueryRequest) Q(q string) ApiForceRunExecutionsByQueryRequest {
	r.q = &q
	return r
}

// The scope of the executions to include
func (r ApiForceRunExecutionsByQueryRequest) Scope(scope []FlowScope) ApiForceRunExecutionsByQueryRequest {
	r.scope = &scope
	return r
}

// A namespace filter prefix
func (r ApiForceRunExecutionsByQueryRequest) Namespace(namespace string) ApiForceRunExecutionsByQueryRequest {
	r.namespace = &namespace
	return r
}

// A flow id filter
func (r ApiForceRunExecutionsByQueryRequest) FlowId(flowId string) ApiForceRunExecutionsByQueryRequest {
	r.flowId = &flowId
	return r
}

// The start datetime
func (r ApiForceRunExecutionsByQueryRequest) StartDate(startDate time.Time) ApiForceRunExecutionsByQueryRequest {
	r.startDate = &startDate
	return r
}

// The end datetime
func (r ApiForceRunExecutionsByQueryRequest) EndDate(endDate time.Time) ApiForceRunExecutionsByQueryRequest {
	r.endDate = &endDate
	return r
}

// A time range filter relative to the current time
func (r ApiForceRunExecutionsByQueryRequest) TimeRange(timeRange string) ApiForceRunExecutionsByQueryRequest {
	r.timeRange = &timeRange
	return r
}

// A state filter
func (r ApiForceRunExecutionsByQueryRequest) State(state []StateType) ApiForceRunExecutionsByQueryRequest {
	r.state = &state
	return r
}

// A labels filter as a list of &#39;key:value&#39;
func (r ApiForceRunExecutionsByQueryRequest) Labels(labels []string) ApiForceRunExecutionsByQueryRequest {
	r.labels = &labels
	return r
}

// The trigger execution id
func (r ApiForceRunExecutionsByQueryRequest) TriggerExecutionId(triggerExecutionId string) ApiForceRunExecutionsByQueryRequest {
	r.triggerExecutionId = &triggerExecutionId
	return r
}

// A execution child filter
func (r ApiForceRunExecutionsByQueryRequest) ChildFilter(childFilter ExecutionRepositoryInterfaceChildFilter) ApiForceRunExecutionsByQueryRequest {
	r.childFilter = &childFilter
	return r
}

func (r ApiForceRunExecutionsByQueryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ForceRunExecutionsByQueryExecute(r)
}

/*
ForceRunExecutionsByQuery Force run executions filter by query parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiForceRunExecutionsByQueryRequest
*/
func (a *ExecutionsAPIService) ForceRunExecutionsByQuery(ctx context.Context, tenant string) ApiForceRunExecutionsByQueryRequest {
	return ApiForceRunExecutionsByQueryRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ExecutionsAPIService) ForceRunExecutionsByQueryExecute(r ApiForceRunExecutionsByQueryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ForceRunExecutionsByQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/force-run/by-query"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deleteExecutionsByQueryRequest == nil {
		return localVarReturnValue, nil, reportError("deleteExecutionsByQueryRequest is required and must be specified")
	}

	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "form", "csv")
	}
	if r.namespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "namespace", r.namespace, "form", "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.timeRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeRange", r.timeRange, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "csv")
	}
	if r.labels != nil {
		t := *r.labels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "labels", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "labels", t, "form", "multi")
		}
	}
	if r.triggerExecutionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "triggerExecutionId", r.triggerExecutionId, "form", "")
	}
	if r.childFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "childFilter", r.childFilter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteExecutionsByQueryRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExecutionRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	tenant      string
}

func (r ApiGetExecutionRequest) Execute() (*Execution, *http.Response, error) {
	return r.ApiService.GetExecutionExecute(r)
}

/*
GetExecution Get an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiGetExecutionRequest
*/
func (a *ExecutionsAPIService) GetExecution(ctx context.Context, executionId string, tenant string) ApiGetExecutionRequest {
	return ApiGetExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return Execution
func (a *ExecutionsAPIService) GetExecutionExecute(r ApiGetExecutionRequest) (*Execution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Execution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.GetExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExecutionFlowGraphRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	tenant      string
	subflows    *[]string
}

// The subflow tasks to display
func (r ApiGetExecutionFlowGraphRequest) Subflows(subflows []string) ApiGetExecutionFlowGraphRequest {
	r.subflows = &subflows
	return r
}

func (r ApiGetExecutionFlowGraphRequest) Execute() (*FlowGraph, *http.Response, error) {
	return r.ApiService.GetExecutionFlowGraphExecute(r)
}

/*
GetExecutionFlowGraph Generate a graph for an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiGetExecutionFlowGraphRequest
*/
func (a *ExecutionsAPIService) GetExecutionFlowGraph(ctx context.Context, executionId string, tenant string) ApiGetExecutionFlowGraphRequest {
	return ApiGetExecutionFlowGraphRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return FlowGraph
func (a *ExecutionsAPIService) GetExecutionFlowGraphExecute(r ApiGetExecutionFlowGraphRequest) (*FlowGraph, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FlowGraph
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.GetExecutionFlowGraph")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/graph"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.subflows != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subflows", r.subflows, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFileMetadatasFromExecutionRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	path        *string
	tenant      string
}

// The internal storage uri
func (r ApiGetFileMetadatasFromExecutionRequest) Path(path string) ApiGetFileMetadatasFromExecutionRequest {
	r.path = &path
	return r
}

func (r ApiGetFileMetadatasFromExecutionRequest) Execute() (*FileMetas, *http.Response, error) {
	return r.ApiService.GetFileMetadatasFromExecutionExecute(r)
}

/*
GetFileMetadatasFromExecution Get file meta information for an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiGetFileMetadatasFromExecutionRequest
*/
func (a *ExecutionsAPIService) GetFileMetadatasFromExecution(ctx context.Context, executionId string, tenant string) ApiGetFileMetadatasFromExecutionRequest {
	return ApiGetFileMetadatasFromExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return FileMetas
func (a *ExecutionsAPIService) GetFileMetadatasFromExecutionExecute(r ApiGetFileMetadatasFromExecutionRequest) (*FileMetas, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FileMetas
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.GetFileMetadatasFromExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/file/metas"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFlowFromExecutionRequest struct {
	ctx        context.Context
	ApiService *ExecutionsAPIService
	namespace  string
	flowId     string
	tenant     string
	revision   *int32
}

// The flow revision
func (r ApiGetFlowFromExecutionRequest) Revision(revision int32) ApiGetFlowFromExecutionRequest {
	r.revision = &revision
	return r
}

func (r ApiGetFlowFromExecutionRequest) Execute() (*FlowForExecution, *http.Response, error) {
	return r.ApiService.GetFlowFromExecutionExecute(r)
}

/*
GetFlowFromExecution Get flow information's for an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param namespace The namespace of the flow
	@param flowId The flow id
	@param tenant
	@return ApiGetFlowFromExecutionRequest
*/
func (a *ExecutionsAPIService) GetFlowFromExecution(ctx context.Context, namespace string, flowId string, tenant string) ApiGetFlowFromExecutionRequest {
	return ApiGetFlowFromExecutionRequest{
		ApiService: a,
		ctx:        ctx,
		namespace:  namespace,
		flowId:     flowId,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return FlowForExecution
func (a *ExecutionsAPIService) GetFlowFromExecutionExecute(r ApiGetFlowFromExecutionRequest) (*FlowForExecution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FlowForExecution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.GetFlowFromExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/flows/{namespace}/{flowId}"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flowId"+"}", url.PathEscape(parameterValueToString(r.flowId, "flowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.revision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revision", r.revision, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFlowFromExecutionByIdRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	tenant      string
}

func (r ApiGetFlowFromExecutionByIdRequest) Execute() (*FlowForExecution, *http.Response, error) {
	return r.ApiService.GetFlowFromExecutionByIdExecute(r)
}

/*
GetFlowFromExecutionById Get flow information's for an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution that you want flow information's
	@param tenant
	@return ApiGetFlowFromExecutionByIdRequest
*/
func (a *ExecutionsAPIService) GetFlowFromExecutionById(ctx context.Context, executionId string, tenant string) ApiGetFlowFromExecutionByIdRequest {
	return ApiGetFlowFromExecutionByIdRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return FlowForExecution
func (a *ExecutionsAPIService) GetFlowFromExecutionByIdExecute(r ApiGetFlowFromExecutionByIdRequest) (*FlowForExecution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FlowForExecution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.GetFlowFromExecutionById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/flow"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLatestExecutionsRequest struct {
	ctx                                    context.Context
	ApiService                             *ExecutionsAPIService
	tenant                                 string
	executionRepositoryInterfaceFlowFilter *[]ExecutionRepositoryInterfaceFlowFilter
}

func (r ApiGetLatestExecutionsRequest) ExecutionRepositoryInterfaceFlowFilter(executionRepositoryInterfaceFlowFilter []ExecutionRepositoryInterfaceFlowFilter) ApiGetLatestExecutionsRequest {
	r.executionRepositoryInterfaceFlowFilter = &executionRepositoryInterfaceFlowFilter
	return r
}

func (r ApiGetLatestExecutionsRequest) Execute() ([]ExecutionControllerLastExecutionResponse, *http.Response, error) {
	return r.ApiService.GetLatestExecutionsExecute(r)
}

/*
GetLatestExecutions Get the latest execution for given flows

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiGetLatestExecutionsRequest
*/
func (a *ExecutionsAPIService) GetLatestExecutions(ctx context.Context, tenant string) ApiGetLatestExecutionsRequest {
	return ApiGetLatestExecutionsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return []ExecutionControllerLastExecutionResponse
func (a *ExecutionsAPIService) GetLatestExecutionsExecute(r ApiGetLatestExecutionsRequest) ([]ExecutionControllerLastExecutionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ExecutionControllerLastExecutionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.GetLatestExecutions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.executionRepositoryInterfaceFlowFilter == nil {
		return localVarReturnValue, nil, reportError("executionRepositoryInterfaceFlowFilter is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.executionRepositoryInterfaceFlowFilter
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKillExecutionRequest struct {
	ctx             context.Context
	ApiService      *ExecutionsAPIService
	executionId     string
	isOnKillCascade *bool
	tenant          string
}

// Specifies whether killing the execution also kill all subflow executions.
func (r ApiKillExecutionRequest) IsOnKillCascade(isOnKillCascade bool) ApiKillExecutionRequest {
	r.isOnKillCascade = &isOnKillCascade
	return r
}

func (r ApiKillExecutionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.KillExecutionExecute(r)
}

/*
KillExecution Kill an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiKillExecutionRequest
*/
func (a *ExecutionsAPIService) KillExecution(ctx context.Context, executionId string, tenant string) ApiKillExecutionRequest {
	return ApiKillExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ExecutionsAPIService) KillExecutionExecute(r ApiKillExecutionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.KillExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/kill"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.isOnKillCascade == nil {
		return localVarReturnValue, nil, reportError("isOnKillCascade is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "isOnKillCascade", r.isOnKillCascade, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKillExecutionsByIdsRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	tenant      string
	requestBody *[]string
}

// The list of executions id
func (r ApiKillExecutionsByIdsRequest) RequestBody(requestBody []string) ApiKillExecutionsByIdsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiKillExecutionsByIdsRequest) Execute() (*BulkResponse, *http.Response, error) {
	return r.ApiService.KillExecutionsByIdsExecute(r)
}

/*
KillExecutionsByIds Kill a list of executions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiKillExecutionsByIdsRequest
*/
func (a *ExecutionsAPIService) KillExecutionsByIds(ctx context.Context, tenant string) ApiKillExecutionsByIdsRequest {
	return ApiKillExecutionsByIdsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BulkResponse
func (a *ExecutionsAPIService) KillExecutionsByIdsExecute(r ApiKillExecutionsByIdsRequest) (*BulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.KillExecutionsByIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/kill/by-ids"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v BulkErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKillExecutionsByQueryRequest struct {
	ctx                            context.Context
	ApiService                     *ExecutionsAPIService
	tenant                         string
	deleteExecutionsByQueryRequest *DeleteExecutionsByQueryRequest
	q                              *string
	scope                          *[]FlowScope
	namespace                      *string
	flowId                         *string
	startDate                      *time.Time
	endDate                        *time.Time
	timeRange                      *string
	state                          *[]StateType
	labels                         *[]string
	triggerExecutionId             *string
	childFilter                    *ExecutionRepositoryInterfaceChildFilter
}

func (r ApiKillExecutionsByQueryRequest) DeleteExecutionsByQueryRequest(deleteExecutionsByQueryRequest DeleteExecutionsByQueryRequest) ApiKillExecutionsByQueryRequest {
	r.deleteExecutionsByQueryRequest = &deleteExecutionsByQueryRequest
	return r
}

// A string filter
func (r ApiKillExecutionsByQueryRequest) Q(q string) ApiKillExecutionsByQueryRequest {
	r.q = &q
	return r
}

// The scope of the executions to include
func (r ApiKillExecutionsByQueryRequest) Scope(scope []FlowScope) ApiKillExecutionsByQueryRequest {
	r.scope = &scope
	return r
}

// A namespace filter prefix
func (r ApiKillExecutionsByQueryRequest) Namespace(namespace string) ApiKillExecutionsByQueryRequest {
	r.namespace = &namespace
	return r
}

// A flow id filter
func (r ApiKillExecutionsByQueryRequest) FlowId(flowId string) ApiKillExecutionsByQueryRequest {
	r.flowId = &flowId
	return r
}

// The start datetime
func (r ApiKillExecutionsByQueryRequest) StartDate(startDate time.Time) ApiKillExecutionsByQueryRequest {
	r.startDate = &startDate
	return r
}

// The end datetime
func (r ApiKillExecutionsByQueryRequest) EndDate(endDate time.Time) ApiKillExecutionsByQueryRequest {
	r.endDate = &endDate
	return r
}

// A time range filter relative to the current time
func (r ApiKillExecutionsByQueryRequest) TimeRange(timeRange string) ApiKillExecutionsByQueryRequest {
	r.timeRange = &timeRange
	return r
}

// A state filter
func (r ApiKillExecutionsByQueryRequest) State(state []StateType) ApiKillExecutionsByQueryRequest {
	r.state = &state
	return r
}

// A labels filter as a list of &#39;key:value&#39;
func (r ApiKillExecutionsByQueryRequest) Labels(labels []string) ApiKillExecutionsByQueryRequest {
	r.labels = &labels
	return r
}

// The trigger execution id
func (r ApiKillExecutionsByQueryRequest) TriggerExecutionId(triggerExecutionId string) ApiKillExecutionsByQueryRequest {
	r.triggerExecutionId = &triggerExecutionId
	return r
}

// A execution child filter
func (r ApiKillExecutionsByQueryRequest) ChildFilter(childFilter ExecutionRepositoryInterfaceChildFilter) ApiKillExecutionsByQueryRequest {
	r.childFilter = &childFilter
	return r
}

func (r ApiKillExecutionsByQueryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.KillExecutionsByQueryExecute(r)
}

/*
KillExecutionsByQuery Kill executions filter by query parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiKillExecutionsByQueryRequest
*/
func (a *ExecutionsAPIService) KillExecutionsByQuery(ctx context.Context, tenant string) ApiKillExecutionsByQueryRequest {
	return ApiKillExecutionsByQueryRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ExecutionsAPIService) KillExecutionsByQueryExecute(r ApiKillExecutionsByQueryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.KillExecutionsByQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/kill/by-query"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deleteExecutionsByQueryRequest == nil {
		return localVarReturnValue, nil, reportError("deleteExecutionsByQueryRequest is required and must be specified")
	}

	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "form", "csv")
	}
	if r.namespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "namespace", r.namespace, "form", "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.timeRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeRange", r.timeRange, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "csv")
	}
	if r.labels != nil {
		t := *r.labels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "labels", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "labels", t, "form", "multi")
		}
	}
	if r.triggerExecutionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "triggerExecutionId", r.triggerExecutionId, "form", "")
	}
	if r.childFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "childFilter", r.childFilter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteExecutionsByQueryRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListExecutableDistinctNamespacesRequest struct {
	ctx        context.Context
	ApiService *ExecutionsAPIService
	tenant     string
}

func (r ApiListExecutableDistinctNamespacesRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.ListExecutableDistinctNamespacesExecute(r)
}

/*
ListExecutableDistinctNamespaces Get all namespaces that have executable flows

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiListExecutableDistinctNamespacesRequest
*/
func (a *ExecutionsAPIService) ListExecutableDistinctNamespaces(ctx context.Context, tenant string) ApiListExecutableDistinctNamespacesRequest {
	return ApiListExecutableDistinctNamespacesRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return []string
func (a *ExecutionsAPIService) ListExecutableDistinctNamespacesExecute(r ApiListExecutableDistinctNamespacesRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ListExecutableDistinctNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/namespaces"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListFlowExecutionsByNamespaceRequest struct {
	ctx        context.Context
	ApiService *ExecutionsAPIService
	namespace  string
	tenant     string
}

func (r ApiListFlowExecutionsByNamespaceRequest) Execute() ([]FlowForExecution, *http.Response, error) {
	return r.ApiService.ListFlowExecutionsByNamespaceExecute(r)
}

/*
ListFlowExecutionsByNamespace Get all flow ids for a namespace. Data returned are FlowForExecution containing minimal information about a Flow for when you are allowed to executing but not reading.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param namespace The namespace
	@param tenant
	@return ApiListFlowExecutionsByNamespaceRequest
*/
func (a *ExecutionsAPIService) ListFlowExecutionsByNamespace(ctx context.Context, namespace string, tenant string) ApiListFlowExecutionsByNamespaceRequest {
	return ApiListFlowExecutionsByNamespaceRequest{
		ApiService: a,
		ctx:        ctx,
		namespace:  namespace,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return []FlowForExecution
func (a *ExecutionsAPIService) ListFlowExecutionsByNamespaceExecute(r ApiListFlowExecutionsByNamespaceRequest) ([]FlowForExecution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []FlowForExecution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ListFlowExecutionsByNamespace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/namespaces/{namespace}/flows"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPauseExecutionRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	tenant      string
}

func (r ApiPauseExecutionRequest) Execute() (*http.Response, error) {
	return r.ApiService.PauseExecutionExecute(r)
}

/*
PauseExecution Pause a running execution.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiPauseExecutionRequest
*/
func (a *ExecutionsAPIService) PauseExecution(ctx context.Context, executionId string, tenant string) ApiPauseExecutionRequest {
	return ApiPauseExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
func (a *ExecutionsAPIService) PauseExecutionExecute(r ApiPauseExecutionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.PauseExecution")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/pause"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPauseExecutionsByIdsRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	tenant      string
	requestBody *[]string
}

// The list of executions id
func (r ApiPauseExecutionsByIdsRequest) RequestBody(requestBody []string) ApiPauseExecutionsByIdsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiPauseExecutionsByIdsRequest) Execute() (*BulkResponse, *http.Response, error) {
	return r.ApiService.PauseExecutionsByIdsExecute(r)
}

/*
PauseExecutionsByIds Pause a list of running executions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiPauseExecutionsByIdsRequest
*/
func (a *ExecutionsAPIService) PauseExecutionsByIds(ctx context.Context, tenant string) ApiPauseExecutionsByIdsRequest {
	return ApiPauseExecutionsByIdsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BulkResponse
func (a *ExecutionsAPIService) PauseExecutionsByIdsExecute(r ApiPauseExecutionsByIdsRequest) (*BulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.PauseExecutionsByIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/pause/by-ids"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v BulkErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPauseExecutionsByQueryRequest struct {
	ctx                            context.Context
	ApiService                     *ExecutionsAPIService
	tenant                         string
	deleteExecutionsByQueryRequest *DeleteExecutionsByQueryRequest
	q                              *string
	scope                          *[]FlowScope
	namespace                      *string
	flowId                         *string
	startDate                      *time.Time
	endDate                        *time.Time
	timeRange                      *string
	state                          *[]StateType
	labels                         *[]string
	triggerExecutionId             *string
	childFilter                    *ExecutionRepositoryInterfaceChildFilter
}

func (r ApiPauseExecutionsByQueryRequest) DeleteExecutionsByQueryRequest(deleteExecutionsByQueryRequest DeleteExecutionsByQueryRequest) ApiPauseExecutionsByQueryRequest {
	r.deleteExecutionsByQueryRequest = &deleteExecutionsByQueryRequest
	return r
}

// A string filter
func (r ApiPauseExecutionsByQueryRequest) Q(q string) ApiPauseExecutionsByQueryRequest {
	r.q = &q
	return r
}

// The scope of the executions to include
func (r ApiPauseExecutionsByQueryRequest) Scope(scope []FlowScope) ApiPauseExecutionsByQueryRequest {
	r.scope = &scope
	return r
}

// A namespace filter prefix
func (r ApiPauseExecutionsByQueryRequest) Namespace(namespace string) ApiPauseExecutionsByQueryRequest {
	r.namespace = &namespace
	return r
}

// A flow id filter
func (r ApiPauseExecutionsByQueryRequest) FlowId(flowId string) ApiPauseExecutionsByQueryRequest {
	r.flowId = &flowId
	return r
}

// The start datetime
func (r ApiPauseExecutionsByQueryRequest) StartDate(startDate time.Time) ApiPauseExecutionsByQueryRequest {
	r.startDate = &startDate
	return r
}

// The end datetime
func (r ApiPauseExecutionsByQueryRequest) EndDate(endDate time.Time) ApiPauseExecutionsByQueryRequest {
	r.endDate = &endDate
	return r
}

// A time range filter relative to the current time
func (r ApiPauseExecutionsByQueryRequest) TimeRange(timeRange string) ApiPauseExecutionsByQueryRequest {
	r.timeRange = &timeRange
	return r
}

// A state filter
func (r ApiPauseExecutionsByQueryRequest) State(state []StateType) ApiPauseExecutionsByQueryRequest {
	r.state = &state
	return r
}

// A labels filter as a list of &#39;key:value&#39;
func (r ApiPauseExecutionsByQueryRequest) Labels(labels []string) ApiPauseExecutionsByQueryRequest {
	r.labels = &labels
	return r
}

// The trigger execution id
func (r ApiPauseExecutionsByQueryRequest) TriggerExecutionId(triggerExecutionId string) ApiPauseExecutionsByQueryRequest {
	r.triggerExecutionId = &triggerExecutionId
	return r
}

// A execution child filter
func (r ApiPauseExecutionsByQueryRequest) ChildFilter(childFilter ExecutionRepositoryInterfaceChildFilter) ApiPauseExecutionsByQueryRequest {
	r.childFilter = &childFilter
	return r
}

func (r ApiPauseExecutionsByQueryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PauseExecutionsByQueryExecute(r)
}

/*
PauseExecutionsByQuery Pause executions filter by query parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiPauseExecutionsByQueryRequest
*/
func (a *ExecutionsAPIService) PauseExecutionsByQuery(ctx context.Context, tenant string) ApiPauseExecutionsByQueryRequest {
	return ApiPauseExecutionsByQueryRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ExecutionsAPIService) PauseExecutionsByQueryExecute(r ApiPauseExecutionsByQueryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.PauseExecutionsByQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/pause/by-query"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deleteExecutionsByQueryRequest == nil {
		return localVarReturnValue, nil, reportError("deleteExecutionsByQueryRequest is required and must be specified")
	}

	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "form", "csv")
	}
	if r.namespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "namespace", r.namespace, "form", "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.timeRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeRange", r.timeRange, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "csv")
	}
	if r.labels != nil {
		t := *r.labels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "labels", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "labels", t, "form", "multi")
		}
	}
	if r.triggerExecutionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "triggerExecutionId", r.triggerExecutionId, "form", "")
	}
	if r.childFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "childFilter", r.childFilter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteExecutionsByQueryRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPreviewFileFromExecutionRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	path        *string
	maxRows     *int32
	encoding    *string
	tenant      string
}

// The internal storage uri
func (r ApiPreviewFileFromExecutionRequest) Path(path string) ApiPreviewFileFromExecutionRequest {
	r.path = &path
	return r
}

// The max row returns
func (r ApiPreviewFileFromExecutionRequest) MaxRows(maxRows int32) ApiPreviewFileFromExecutionRequest {
	r.maxRows = &maxRows
	return r
}

// The file encoding as Java charset name. Defaults to UTF-8
func (r ApiPreviewFileFromExecutionRequest) Encoding(encoding string) ApiPreviewFileFromExecutionRequest {
	r.encoding = &encoding
	return r
}

func (r ApiPreviewFileFromExecutionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PreviewFileFromExecutionExecute(r)
}

/*
PreviewFileFromExecution Get file preview for an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiPreviewFileFromExecutionRequest
*/
func (a *ExecutionsAPIService) PreviewFileFromExecution(ctx context.Context, executionId string, tenant string) ApiPreviewFileFromExecutionRequest {
	return ApiPreviewFileFromExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ExecutionsAPIService) PreviewFileFromExecutionExecute(r ApiPreviewFileFromExecutionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.PreviewFileFromExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/file/preview"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}
	if r.maxRows == nil {
		return localVarReturnValue, nil, reportError("maxRows is required and must be specified")
	}
	if r.encoding == nil {
		return localVarReturnValue, nil, reportError("encoding is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "maxRows", r.maxRows, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "encoding", r.encoding, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplayExecutionRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	tenant      string
	taskRunId   *string
	revision    *int32
	breakpoints *string
}

// The taskrun id
func (r ApiReplayExecutionRequest) TaskRunId(taskRunId string) ApiReplayExecutionRequest {
	r.taskRunId = &taskRunId
	return r
}

// The flow revision to use for new execution
func (r ApiReplayExecutionRequest) Revision(revision int32) ApiReplayExecutionRequest {
	r.revision = &revision
	return r
}

// Set a list of breakpoints at specific tasks &#39;id.value&#39;, separated by a coma.
func (r ApiReplayExecutionRequest) Breakpoints(breakpoints string) ApiReplayExecutionRequest {
	r.breakpoints = &breakpoints
	return r
}

func (r ApiReplayExecutionRequest) Execute() (*Execution, *http.Response, error) {
	return r.ApiService.ReplayExecutionExecute(r)
}

/*
ReplayExecution Create a new execution from an old one and start it from a specified task run id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId the original execution id to clone
	@param tenant
	@return ApiReplayExecutionRequest
*/
func (a *ExecutionsAPIService) ReplayExecution(ctx context.Context, executionId string, tenant string) ApiReplayExecutionRequest {
	return ApiReplayExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return Execution
func (a *ExecutionsAPIService) ReplayExecutionExecute(r ApiReplayExecutionRequest) (*Execution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Execution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ReplayExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/replay"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.taskRunId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskRunId", r.taskRunId, "form", "")
	}
	if r.revision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revision", r.revision, "form", "")
	}
	if r.breakpoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakpoints", r.breakpoints, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplayExecutionWithinputsRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	tenant      string
	taskRunId   *string
	revision    *int32
	breakpoints *string
}

// The taskrun id
func (r ApiReplayExecutionWithinputsRequest) TaskRunId(taskRunId string) ApiReplayExecutionWithinputsRequest {
	r.taskRunId = &taskRunId
	return r
}

// The flow revision to use for new execution
func (r ApiReplayExecutionWithinputsRequest) Revision(revision int32) ApiReplayExecutionWithinputsRequest {
	r.revision = &revision
	return r
}

// Set a list of breakpoints at specific tasks &#39;id.value&#39;, separated by a coma.
func (r ApiReplayExecutionWithinputsRequest) Breakpoints(breakpoints string) ApiReplayExecutionWithinputsRequest {
	r.breakpoints = &breakpoints
	return r
}

func (r ApiReplayExecutionWithinputsRequest) Execute() (*Execution, *http.Response, error) {
	return r.ApiService.ReplayExecutionWithinputsExecute(r)
}

/*
ReplayExecutionWithinputs Create a new execution from an old one and start it from a specified task run id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId the original execution id to clone
	@param tenant
	@return ApiReplayExecutionWithinputsRequest
*/
func (a *ExecutionsAPIService) ReplayExecutionWithinputs(ctx context.Context, executionId string, tenant string) ApiReplayExecutionWithinputsRequest {
	return ApiReplayExecutionWithinputsRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return Execution
func (a *ExecutionsAPIService) ReplayExecutionWithinputsExecute(r ApiReplayExecutionWithinputsRequest) (*Execution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Execution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ReplayExecutionWithinputs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/replay-with-inputs"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.taskRunId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskRunId", r.taskRunId, "form", "")
	}
	if r.revision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revision", r.revision, "form", "")
	}
	if r.breakpoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakpoints", r.breakpoints, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplayExecutionsByIdsRequest struct {
	ctx            context.Context
	ApiService     *ExecutionsAPIService
	tenant         string
	requestBody    *[]string
	latestRevision *bool
}

// The list of executions id
func (r ApiReplayExecutionsByIdsRequest) RequestBody(requestBody []string) ApiReplayExecutionsByIdsRequest {
	r.requestBody = &requestBody
	return r
}

// If latest revision should be used
func (r ApiReplayExecutionsByIdsRequest) LatestRevision(latestRevision bool) ApiReplayExecutionsByIdsRequest {
	r.latestRevision = &latestRevision
	return r
}

func (r ApiReplayExecutionsByIdsRequest) Execute() (*BulkResponse, *http.Response, error) {
	return r.ApiService.ReplayExecutionsByIdsExecute(r)
}

/*
ReplayExecutionsByIds Create new executions from old ones. Keep the flow revision

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiReplayExecutionsByIdsRequest
*/
func (a *ExecutionsAPIService) ReplayExecutionsByIds(ctx context.Context, tenant string) ApiReplayExecutionsByIdsRequest {
	return ApiReplayExecutionsByIdsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BulkResponse
func (a *ExecutionsAPIService) ReplayExecutionsByIdsExecute(r ApiReplayExecutionsByIdsRequest) (*BulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ReplayExecutionsByIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/replay/by-ids"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	if r.latestRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latestRevision", r.latestRevision, "form", "")
	} else {
		var defaultValue bool = false
		r.latestRevision = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v BulkErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplayExecutionsByQueryRequest struct {
	ctx                            context.Context
	ApiService                     *ExecutionsAPIService
	tenant                         string
	deleteExecutionsByQueryRequest *DeleteExecutionsByQueryRequest
	q                              *string
	scope                          *[]FlowScope
	namespace                      *string
	flowId                         *string
	startDate                      *time.Time
	endDate                        *time.Time
	timeRange                      *string
	state                          *[]StateType
	labels                         *[]string
	triggerExecutionId             *string
	childFilter                    *ExecutionRepositoryInterfaceChildFilter
	latestRevision                 *bool
}

func (r ApiReplayExecutionsByQueryRequest) DeleteExecutionsByQueryRequest(deleteExecutionsByQueryRequest DeleteExecutionsByQueryRequest) ApiReplayExecutionsByQueryRequest {
	r.deleteExecutionsByQueryRequest = &deleteExecutionsByQueryRequest
	return r
}

// A string filter
func (r ApiReplayExecutionsByQueryRequest) Q(q string) ApiReplayExecutionsByQueryRequest {
	r.q = &q
	return r
}

// The scope of the executions to include
func (r ApiReplayExecutionsByQueryRequest) Scope(scope []FlowScope) ApiReplayExecutionsByQueryRequest {
	r.scope = &scope
	return r
}

// A namespace filter prefix
func (r ApiReplayExecutionsByQueryRequest) Namespace(namespace string) ApiReplayExecutionsByQueryRequest {
	r.namespace = &namespace
	return r
}

// A flow id filter
func (r ApiReplayExecutionsByQueryRequest) FlowId(flowId string) ApiReplayExecutionsByQueryRequest {
	r.flowId = &flowId
	return r
}

// The start datetime
func (r ApiReplayExecutionsByQueryRequest) StartDate(startDate time.Time) ApiReplayExecutionsByQueryRequest {
	r.startDate = &startDate
	return r
}

// The end datetime
func (r ApiReplayExecutionsByQueryRequest) EndDate(endDate time.Time) ApiReplayExecutionsByQueryRequest {
	r.endDate = &endDate
	return r
}

// A time range filter relative to the current time
func (r ApiReplayExecutionsByQueryRequest) TimeRange(timeRange string) ApiReplayExecutionsByQueryRequest {
	r.timeRange = &timeRange
	return r
}

// A state filter
func (r ApiReplayExecutionsByQueryRequest) State(state []StateType) ApiReplayExecutionsByQueryRequest {
	r.state = &state
	return r
}

// A labels filter as a list of &#39;key:value&#39;
func (r ApiReplayExecutionsByQueryRequest) Labels(labels []string) ApiReplayExecutionsByQueryRequest {
	r.labels = &labels
	return r
}

// The trigger execution id
func (r ApiReplayExecutionsByQueryRequest) TriggerExecutionId(triggerExecutionId string) ApiReplayExecutionsByQueryRequest {
	r.triggerExecutionId = &triggerExecutionId
	return r
}

// A execution child filter
func (r ApiReplayExecutionsByQueryRequest) ChildFilter(childFilter ExecutionRepositoryInterfaceChildFilter) ApiReplayExecutionsByQueryRequest {
	r.childFilter = &childFilter
	return r
}

// If latest revision should be used
func (r ApiReplayExecutionsByQueryRequest) LatestRevision(latestRevision bool) ApiReplayExecutionsByQueryRequest {
	r.latestRevision = &latestRevision
	return r
}

func (r ApiReplayExecutionsByQueryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ReplayExecutionsByQueryExecute(r)
}

/*
ReplayExecutionsByQuery Create new executions from old ones filter by query parameters. Keep the flow revision

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiReplayExecutionsByQueryRequest
*/
func (a *ExecutionsAPIService) ReplayExecutionsByQuery(ctx context.Context, tenant string) ApiReplayExecutionsByQueryRequest {
	return ApiReplayExecutionsByQueryRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ExecutionsAPIService) ReplayExecutionsByQueryExecute(r ApiReplayExecutionsByQueryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ReplayExecutionsByQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/replay/by-query"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deleteExecutionsByQueryRequest == nil {
		return localVarReturnValue, nil, reportError("deleteExecutionsByQueryRequest is required and must be specified")
	}

	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "form", "csv")
	}
	if r.namespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "namespace", r.namespace, "form", "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.timeRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeRange", r.timeRange, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "csv")
	}
	if r.labels != nil {
		t := *r.labels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "labels", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "labels", t, "form", "multi")
		}
	}
	if r.triggerExecutionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "triggerExecutionId", r.triggerExecutionId, "form", "")
	}
	if r.childFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "childFilter", r.childFilter, "form", "")
	}
	if r.latestRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latestRevision", r.latestRevision, "form", "")
	} else {
		var defaultValue bool = false
		r.latestRevision = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteExecutionsByQueryRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestartExecutionRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	tenant      string
	revision    *int32
}

// The flow revision to use for new execution
func (r ApiRestartExecutionRequest) Revision(revision int32) ApiRestartExecutionRequest {
	r.revision = &revision
	return r
}

func (r ApiRestartExecutionRequest) Execute() (*Execution, *http.Response, error) {
	return r.ApiService.RestartExecutionExecute(r)
}

/*
RestartExecution Restart a new execution from an old one

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiRestartExecutionRequest
*/
func (a *ExecutionsAPIService) RestartExecution(ctx context.Context, executionId string, tenant string) ApiRestartExecutionRequest {
	return ApiRestartExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return Execution
func (a *ExecutionsAPIService) RestartExecutionExecute(r ApiRestartExecutionRequest) (*Execution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Execution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.RestartExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/restart"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.revision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revision", r.revision, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestartExecutionsByIdsRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	tenant      string
	requestBody *[]string
}

// The list of executions id
func (r ApiRestartExecutionsByIdsRequest) RequestBody(requestBody []string) ApiRestartExecutionsByIdsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiRestartExecutionsByIdsRequest) Execute() (*BulkResponse, *http.Response, error) {
	return r.ApiService.RestartExecutionsByIdsExecute(r)
}

/*
RestartExecutionsByIds Restart a list of executions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiRestartExecutionsByIdsRequest
*/
func (a *ExecutionsAPIService) RestartExecutionsByIds(ctx context.Context, tenant string) ApiRestartExecutionsByIdsRequest {
	return ApiRestartExecutionsByIdsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BulkResponse
func (a *ExecutionsAPIService) RestartExecutionsByIdsExecute(r ApiRestartExecutionsByIdsRequest) (*BulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.RestartExecutionsByIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/restart/by-ids"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v BulkErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestartExecutionsByQueryRequest struct {
	ctx                            context.Context
	ApiService                     *ExecutionsAPIService
	tenant                         string
	deleteExecutionsByQueryRequest *DeleteExecutionsByQueryRequest
	q                              *string
	scope                          *[]FlowScope
	namespace                      *string
	flowId                         *string
	startDate                      *time.Time
	endDate                        *time.Time
	timeRange                      *string
	state                          *[]StateType
	labels                         *[]string
	triggerExecutionId             *string
	childFilter                    *ExecutionRepositoryInterfaceChildFilter
}

func (r ApiRestartExecutionsByQueryRequest) DeleteExecutionsByQueryRequest(deleteExecutionsByQueryRequest DeleteExecutionsByQueryRequest) ApiRestartExecutionsByQueryRequest {
	r.deleteExecutionsByQueryRequest = &deleteExecutionsByQueryRequest
	return r
}

// A string filter
func (r ApiRestartExecutionsByQueryRequest) Q(q string) ApiRestartExecutionsByQueryRequest {
	r.q = &q
	return r
}

// The scope of the executions to include
func (r ApiRestartExecutionsByQueryRequest) Scope(scope []FlowScope) ApiRestartExecutionsByQueryRequest {
	r.scope = &scope
	return r
}

// A namespace filter prefix
func (r ApiRestartExecutionsByQueryRequest) Namespace(namespace string) ApiRestartExecutionsByQueryRequest {
	r.namespace = &namespace
	return r
}

// A flow id filter
func (r ApiRestartExecutionsByQueryRequest) FlowId(flowId string) ApiRestartExecutionsByQueryRequest {
	r.flowId = &flowId
	return r
}

// The start datetime
func (r ApiRestartExecutionsByQueryRequest) StartDate(startDate time.Time) ApiRestartExecutionsByQueryRequest {
	r.startDate = &startDate
	return r
}

// The end datetime
func (r ApiRestartExecutionsByQueryRequest) EndDate(endDate time.Time) ApiRestartExecutionsByQueryRequest {
	r.endDate = &endDate
	return r
}

// A time range filter relative to the current time
func (r ApiRestartExecutionsByQueryRequest) TimeRange(timeRange string) ApiRestartExecutionsByQueryRequest {
	r.timeRange = &timeRange
	return r
}

// A state filter
func (r ApiRestartExecutionsByQueryRequest) State(state []StateType) ApiRestartExecutionsByQueryRequest {
	r.state = &state
	return r
}

// A labels filter as a list of &#39;key:value&#39;
func (r ApiRestartExecutionsByQueryRequest) Labels(labels []string) ApiRestartExecutionsByQueryRequest {
	r.labels = &labels
	return r
}

// The trigger execution id
func (r ApiRestartExecutionsByQueryRequest) TriggerExecutionId(triggerExecutionId string) ApiRestartExecutionsByQueryRequest {
	r.triggerExecutionId = &triggerExecutionId
	return r
}

// A execution child filter
func (r ApiRestartExecutionsByQueryRequest) ChildFilter(childFilter ExecutionRepositoryInterfaceChildFilter) ApiRestartExecutionsByQueryRequest {
	r.childFilter = &childFilter
	return r
}

func (r ApiRestartExecutionsByQueryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.RestartExecutionsByQueryExecute(r)
}

/*
RestartExecutionsByQuery Restart executions filter by query parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiRestartExecutionsByQueryRequest
*/
func (a *ExecutionsAPIService) RestartExecutionsByQuery(ctx context.Context, tenant string) ApiRestartExecutionsByQueryRequest {
	return ApiRestartExecutionsByQueryRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ExecutionsAPIService) RestartExecutionsByQueryExecute(r ApiRestartExecutionsByQueryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.RestartExecutionsByQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/restart/by-query"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deleteExecutionsByQueryRequest == nil {
		return localVarReturnValue, nil, reportError("deleteExecutionsByQueryRequest is required and must be specified")
	}

	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "form", "csv")
	}
	if r.namespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "namespace", r.namespace, "form", "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.timeRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeRange", r.timeRange, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "csv")
	}
	if r.labels != nil {
		t := *r.labels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "labels", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "labels", t, "form", "multi")
		}
	}
	if r.triggerExecutionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "triggerExecutionId", r.triggerExecutionId, "form", "")
	}
	if r.childFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "childFilter", r.childFilter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteExecutionsByQueryRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResumeExecutionRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	tenant      string
}

func (r ApiResumeExecutionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ResumeExecutionExecute(r)
}

/*
ResumeExecution Resume a paused execution.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiResumeExecutionRequest
*/
func (a *ExecutionsAPIService) ResumeExecution(ctx context.Context, executionId string, tenant string) ApiResumeExecutionRequest {
	return ApiResumeExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ExecutionsAPIService) ResumeExecutionExecute(r ApiResumeExecutionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ResumeExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/resume"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResumeExecutionFromBreakpointRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	tenant      string
	breakpoints *string
}

// \&quot;Set a list of breakpoints at specific tasks &#39;id.value&#39;, separated by a coma.
func (r ApiResumeExecutionFromBreakpointRequest) Breakpoints(breakpoints string) ApiResumeExecutionFromBreakpointRequest {
	r.breakpoints = &breakpoints
	return r
}

func (r ApiResumeExecutionFromBreakpointRequest) Execute() (*http.Response, error) {
	return r.ApiService.ResumeExecutionFromBreakpointExecute(r)
}

/*
ResumeExecutionFromBreakpoint Resume an execution from a breakpoint (in the 'BREAKPOINT' state).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiResumeExecutionFromBreakpointRequest
*/
func (a *ExecutionsAPIService) ResumeExecutionFromBreakpoint(ctx context.Context, executionId string, tenant string) ApiResumeExecutionFromBreakpointRequest {
	return ApiResumeExecutionFromBreakpointRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
func (a *ExecutionsAPIService) ResumeExecutionFromBreakpointExecute(r ApiResumeExecutionFromBreakpointRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ResumeExecutionFromBreakpoint")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/resume-from-breakpoint"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.breakpoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakpoints", r.breakpoints, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiResumeExecutionsByIdsRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	tenant      string
	requestBody *[]string
}

// The list of executions id
func (r ApiResumeExecutionsByIdsRequest) RequestBody(requestBody []string) ApiResumeExecutionsByIdsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiResumeExecutionsByIdsRequest) Execute() (*BulkResponse, *http.Response, error) {
	return r.ApiService.ResumeExecutionsByIdsExecute(r)
}

/*
ResumeExecutionsByIds Resume a list of paused executions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiResumeExecutionsByIdsRequest
*/
func (a *ExecutionsAPIService) ResumeExecutionsByIds(ctx context.Context, tenant string) ApiResumeExecutionsByIdsRequest {
	return ApiResumeExecutionsByIdsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BulkResponse
func (a *ExecutionsAPIService) ResumeExecutionsByIdsExecute(r ApiResumeExecutionsByIdsRequest) (*BulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ResumeExecutionsByIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/resume/by-ids"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v BulkErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResumeExecutionsByQueryRequest struct {
	ctx                            context.Context
	ApiService                     *ExecutionsAPIService
	tenant                         string
	deleteExecutionsByQueryRequest *DeleteExecutionsByQueryRequest
	q                              *string
	scope                          *[]FlowScope
	namespace                      *string
	flowId                         *string
	startDate                      *time.Time
	endDate                        *time.Time
	timeRange                      *string
	state                          *[]StateType
	labels                         *[]string
	triggerExecutionId             *string
	childFilter                    *ExecutionRepositoryInterfaceChildFilter
}

func (r ApiResumeExecutionsByQueryRequest) DeleteExecutionsByQueryRequest(deleteExecutionsByQueryRequest DeleteExecutionsByQueryRequest) ApiResumeExecutionsByQueryRequest {
	r.deleteExecutionsByQueryRequest = &deleteExecutionsByQueryRequest
	return r
}

// A string filter
func (r ApiResumeExecutionsByQueryRequest) Q(q string) ApiResumeExecutionsByQueryRequest {
	r.q = &q
	return r
}

// The scope of the executions to include
func (r ApiResumeExecutionsByQueryRequest) Scope(scope []FlowScope) ApiResumeExecutionsByQueryRequest {
	r.scope = &scope
	return r
}

// A namespace filter prefix
func (r ApiResumeExecutionsByQueryRequest) Namespace(namespace string) ApiResumeExecutionsByQueryRequest {
	r.namespace = &namespace
	return r
}

// A flow id filter
func (r ApiResumeExecutionsByQueryRequest) FlowId(flowId string) ApiResumeExecutionsByQueryRequest {
	r.flowId = &flowId
	return r
}

// The start datetime
func (r ApiResumeExecutionsByQueryRequest) StartDate(startDate time.Time) ApiResumeExecutionsByQueryRequest {
	r.startDate = &startDate
	return r
}

// The end datetime
func (r ApiResumeExecutionsByQueryRequest) EndDate(endDate time.Time) ApiResumeExecutionsByQueryRequest {
	r.endDate = &endDate
	return r
}

// A time range filter relative to the current time
func (r ApiResumeExecutionsByQueryRequest) TimeRange(timeRange string) ApiResumeExecutionsByQueryRequest {
	r.timeRange = &timeRange
	return r
}

// A state filter
func (r ApiResumeExecutionsByQueryRequest) State(state []StateType) ApiResumeExecutionsByQueryRequest {
	r.state = &state
	return r
}

// A labels filter as a list of &#39;key:value&#39;
func (r ApiResumeExecutionsByQueryRequest) Labels(labels []string) ApiResumeExecutionsByQueryRequest {
	r.labels = &labels
	return r
}

// The trigger execution id
func (r ApiResumeExecutionsByQueryRequest) TriggerExecutionId(triggerExecutionId string) ApiResumeExecutionsByQueryRequest {
	r.triggerExecutionId = &triggerExecutionId
	return r
}

// A execution child filter
func (r ApiResumeExecutionsByQueryRequest) ChildFilter(childFilter ExecutionRepositoryInterfaceChildFilter) ApiResumeExecutionsByQueryRequest {
	r.childFilter = &childFilter
	return r
}

func (r ApiResumeExecutionsByQueryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ResumeExecutionsByQueryExecute(r)
}

/*
ResumeExecutionsByQuery Resume executions filter by query parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiResumeExecutionsByQueryRequest
*/
func (a *ExecutionsAPIService) ResumeExecutionsByQuery(ctx context.Context, tenant string) ApiResumeExecutionsByQueryRequest {
	return ApiResumeExecutionsByQueryRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ExecutionsAPIService) ResumeExecutionsByQueryExecute(r ApiResumeExecutionsByQueryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ResumeExecutionsByQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/resume/by-query"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deleteExecutionsByQueryRequest == nil {
		return localVarReturnValue, nil, reportError("deleteExecutionsByQueryRequest is required and must be specified")
	}

	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "form", "csv")
	}
	if r.namespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "namespace", r.namespace, "form", "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.timeRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeRange", r.timeRange, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "csv")
	}
	if r.labels != nil {
		t := *r.labels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "labels", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "labels", t, "form", "multi")
		}
	}
	if r.triggerExecutionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "triggerExecutionId", r.triggerExecutionId, "form", "")
	}
	if r.childFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "childFilter", r.childFilter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteExecutionsByQueryRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchExecutionsRequest struct {
	ctx                context.Context
	ApiService         *ExecutionsAPIService
	page               *int32
	size               *int32
	tenant             string
	sort               *[]string
	filters            *[]QueryFilter
	q                  *string
	scope              *[]FlowScope
	namespace          *string
	flowId             *string
	startDate          *time.Time
	endDate            *time.Time
	timeRange          *string
	state              *[]StateType
	labels             *[]string
	triggerExecutionId *string
	childFilter        *ExecutionRepositoryInterfaceChildFilter
}

// The current page
func (r ApiSearchExecutionsRequest) Page(page int32) ApiSearchExecutionsRequest {
	r.page = &page
	return r
}

// The current page size
func (r ApiSearchExecutionsRequest) Size(size int32) ApiSearchExecutionsRequest {
	r.size = &size
	return r
}

// The sort of current page
func (r ApiSearchExecutionsRequest) Sort(sort []string) ApiSearchExecutionsRequest {
	r.sort = &sort
	return r
}

// Filters
func (r ApiSearchExecutionsRequest) Filters(filters []QueryFilter) ApiSearchExecutionsRequest {
	r.filters = &filters
	return r
}

// A string filter
// Deprecated
func (r ApiSearchExecutionsRequest) Q(q string) ApiSearchExecutionsRequest {
	r.q = &q
	return r
}

// The scope of the executions to include
// Deprecated
func (r ApiSearchExecutionsRequest) Scope(scope []FlowScope) ApiSearchExecutionsRequest {
	r.scope = &scope
	return r
}

// A namespace filter prefix
// Deprecated
func (r ApiSearchExecutionsRequest) Namespace(namespace string) ApiSearchExecutionsRequest {
	r.namespace = &namespace
	return r
}

// A flow id filter
// Deprecated
func (r ApiSearchExecutionsRequest) FlowId(flowId string) ApiSearchExecutionsRequest {
	r.flowId = &flowId
	return r
}

// The start datetime
// Deprecated
func (r ApiSearchExecutionsRequest) StartDate(startDate time.Time) ApiSearchExecutionsRequest {
	r.startDate = &startDate
	return r
}

// The end datetime
// Deprecated
func (r ApiSearchExecutionsRequest) EndDate(endDate time.Time) ApiSearchExecutionsRequest {
	r.endDate = &endDate
	return r
}

// A time range filter relative to the current time
// Deprecated
func (r ApiSearchExecutionsRequest) TimeRange(timeRange string) ApiSearchExecutionsRequest {
	r.timeRange = &timeRange
	return r
}

// A state filter
// Deprecated
func (r ApiSearchExecutionsRequest) State(state []StateType) ApiSearchExecutionsRequest {
	r.state = &state
	return r
}

// A labels filter as a list of &#39;key:value&#39;
// Deprecated
func (r ApiSearchExecutionsRequest) Labels(labels []string) ApiSearchExecutionsRequest {
	r.labels = &labels
	return r
}

// The trigger execution id
// Deprecated
func (r ApiSearchExecutionsRequest) TriggerExecutionId(triggerExecutionId string) ApiSearchExecutionsRequest {
	r.triggerExecutionId = &triggerExecutionId
	return r
}

// A execution child filter
// Deprecated
func (r ApiSearchExecutionsRequest) ChildFilter(childFilter ExecutionRepositoryInterfaceChildFilter) ApiSearchExecutionsRequest {
	r.childFilter = &childFilter
	return r
}

func (r ApiSearchExecutionsRequest) Execute() (*PagedResultsExecution, *http.Response, error) {
	return r.ApiService.SearchExecutionsExecute(r)
}

/*
SearchExecutions Search for executions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiSearchExecutionsRequest
*/
func (a *ExecutionsAPIService) SearchExecutions(ctx context.Context, tenant string) ApiSearchExecutionsRequest {
	return ApiSearchExecutionsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return PagedResultsExecution
func (a *ExecutionsAPIService) SearchExecutionsExecute(r ApiSearchExecutionsRequest) (*PagedResultsExecution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PagedResultsExecution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.SearchExecutions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/search"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if *r.page < 1 {
		return localVarReturnValue, nil, reportError("page must be greater than 1")
	}
	if r.size == nil {
		return localVarReturnValue, nil, reportError("size is required and must be specified")
	}
	if *r.size < 1 {
		return localVarReturnValue, nil, reportError("size must be greater than 1")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "csv")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters", r.filters, "form", "csv")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "form", "csv")
	}
	if r.namespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "namespace", r.namespace, "form", "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.timeRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeRange", r.timeRange, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "csv")
	}
	if r.labels != nil {
		t := *r.labels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "labels", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "labels", t, "form", "multi")
		}
	}
	if r.triggerExecutionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "triggerExecutionId", r.triggerExecutionId, "form", "")
	}
	if r.childFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "childFilter", r.childFilter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchExecutionsByFlowIdRequest struct {
	ctx        context.Context
	ApiService *ExecutionsAPIService
	namespace  *string
	flowId     *string
	page       *int32
	size       *int32
	tenant     string
}

// The flow namespace
func (r ApiSearchExecutionsByFlowIdRequest) Namespace(namespace string) ApiSearchExecutionsByFlowIdRequest {
	r.namespace = &namespace
	return r
}

// The flow id
func (r ApiSearchExecutionsByFlowIdRequest) FlowId(flowId string) ApiSearchExecutionsByFlowIdRequest {
	r.flowId = &flowId
	return r
}

// The current page
func (r ApiSearchExecutionsByFlowIdRequest) Page(page int32) ApiSearchExecutionsByFlowIdRequest {
	r.page = &page
	return r
}

// The current page size
func (r ApiSearchExecutionsByFlowIdRequest) Size(size int32) ApiSearchExecutionsByFlowIdRequest {
	r.size = &size
	return r
}

func (r ApiSearchExecutionsByFlowIdRequest) Execute() (*PagedResultsExecution, *http.Response, error) {
	return r.ApiService.SearchExecutionsByFlowIdExecute(r)
}

/*
SearchExecutionsByFlowId Search for executions for a flow

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiSearchExecutionsByFlowIdRequest
*/
func (a *ExecutionsAPIService) SearchExecutionsByFlowId(ctx context.Context, tenant string) ApiSearchExecutionsByFlowIdRequest {
	return ApiSearchExecutionsByFlowIdRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return PagedResultsExecution
func (a *ExecutionsAPIService) SearchExecutionsByFlowIdExecute(r ApiSearchExecutionsByFlowIdRequest) (*PagedResultsExecution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PagedResultsExecution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.SearchExecutionsByFlowId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.namespace == nil {
		return localVarReturnValue, nil, reportError("namespace is required and must be specified")
	}
	if r.flowId == nil {
		return localVarReturnValue, nil, reportError("flowId is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if *r.page < 1 {
		return localVarReturnValue, nil, reportError("page must be greater than 1")
	}
	if r.size == nil {
		return localVarReturnValue, nil, reportError("size is required and must be specified")
	}
	if *r.size < 1 {
		return localVarReturnValue, nil, reportError("size must be greater than 1")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "namespace", r.namespace, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchTaskRunRequest struct {
	ctx                context.Context
	ApiService         *ExecutionsAPIService
	page               *int32
	size               *int32
	tenant             string
	sort               *[]string
	filters            *[]QueryFilter
	q                  *string
	namespace          *string
	flowId             *string
	startDate          *time.Time
	endDate            *time.Time
	timeRange          *string
	state              *[]StateType
	labels             *[]string
	triggerExecutionId *string
	childFilter        *ExecutionRepositoryInterfaceChildFilter
}

// The current page
func (r ApiSearchTaskRunRequest) Page(page int32) ApiSearchTaskRunRequest {
	r.page = &page
	return r
}

// The current page size
func (r ApiSearchTaskRunRequest) Size(size int32) ApiSearchTaskRunRequest {
	r.size = &size
	return r
}

// The sort of current page
func (r ApiSearchTaskRunRequest) Sort(sort []string) ApiSearchTaskRunRequest {
	r.sort = &sort
	return r
}

// Filters
func (r ApiSearchTaskRunRequest) Filters(filters []QueryFilter) ApiSearchTaskRunRequest {
	r.filters = &filters
	return r
}

// A string filter
// Deprecated
func (r ApiSearchTaskRunRequest) Q(q string) ApiSearchTaskRunRequest {
	r.q = &q
	return r
}

// A namespace filter prefix
// Deprecated
func (r ApiSearchTaskRunRequest) Namespace(namespace string) ApiSearchTaskRunRequest {
	r.namespace = &namespace
	return r
}

// A flow id filter
// Deprecated
func (r ApiSearchTaskRunRequest) FlowId(flowId string) ApiSearchTaskRunRequest {
	r.flowId = &flowId
	return r
}

// The start datetime
// Deprecated
func (r ApiSearchTaskRunRequest) StartDate(startDate time.Time) ApiSearchTaskRunRequest {
	r.startDate = &startDate
	return r
}

// The end datetime
// Deprecated
func (r ApiSearchTaskRunRequest) EndDate(endDate time.Time) ApiSearchTaskRunRequest {
	r.endDate = &endDate
	return r
}

// A time range filter relative to the current time
// Deprecated
func (r ApiSearchTaskRunRequest) TimeRange(timeRange string) ApiSearchTaskRunRequest {
	r.timeRange = &timeRange
	return r
}

// A state filter
// Deprecated
func (r ApiSearchTaskRunRequest) State(state []StateType) ApiSearchTaskRunRequest {
	r.state = &state
	return r
}

// A labels filter as a list of &#39;key:value&#39;
// Deprecated
func (r ApiSearchTaskRunRequest) Labels(labels []string) ApiSearchTaskRunRequest {
	r.labels = &labels
	return r
}

// The trigger execution id
// Deprecated
func (r ApiSearchTaskRunRequest) TriggerExecutionId(triggerExecutionId string) ApiSearchTaskRunRequest {
	r.triggerExecutionId = &triggerExecutionId
	return r
}

// A execution child filter
// Deprecated
func (r ApiSearchTaskRunRequest) ChildFilter(childFilter ExecutionRepositoryInterfaceChildFilter) ApiSearchTaskRunRequest {
	r.childFilter = &childFilter
	return r
}

func (r ApiSearchTaskRunRequest) Execute() (*PagedResultsTaskRun, *http.Response, error) {
	return r.ApiService.SearchTaskRunExecute(r)
}

/*
SearchTaskRun Search for taskruns, only available with the Elasticsearch repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiSearchTaskRunRequest
*/
func (a *ExecutionsAPIService) SearchTaskRun(ctx context.Context, tenant string) ApiSearchTaskRunRequest {
	return ApiSearchTaskRunRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return PagedResultsTaskRun
func (a *ExecutionsAPIService) SearchTaskRunExecute(r ApiSearchTaskRunRequest) (*PagedResultsTaskRun, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PagedResultsTaskRun
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.SearchTaskRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/taskruns/search"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if *r.page < 1 {
		return localVarReturnValue, nil, reportError("page must be greater than 1")
	}
	if r.size == nil {
		return localVarReturnValue, nil, reportError("size is required and must be specified")
	}
	if *r.size < 1 {
		return localVarReturnValue, nil, reportError("size must be greater than 1")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "csv")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters", r.filters, "form", "csv")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.namespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "namespace", r.namespace, "form", "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.timeRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeRange", r.timeRange, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "csv")
	}
	if r.labels != nil {
		t := *r.labels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "labels", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "labels", t, "form", "multi")
		}
	}
	if r.triggerExecutionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "triggerExecutionId", r.triggerExecutionId, "form", "")
	}
	if r.childFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "childFilter", r.childFilter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetLabelsOnTerminatedExecutionRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	tenant      string
	label       *[]Label
}

// The labels to add to the execution
func (r ApiSetLabelsOnTerminatedExecutionRequest) Label(label []Label) ApiSetLabelsOnTerminatedExecutionRequest {
	r.label = &label
	return r
}

func (r ApiSetLabelsOnTerminatedExecutionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SetLabelsOnTerminatedExecutionExecute(r)
}

/*
SetLabelsOnTerminatedExecution Add or update labels of a terminated execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiSetLabelsOnTerminatedExecutionRequest
*/
func (a *ExecutionsAPIService) SetLabelsOnTerminatedExecution(ctx context.Context, executionId string, tenant string) ApiSetLabelsOnTerminatedExecutionRequest {
	return ApiSetLabelsOnTerminatedExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ExecutionsAPIService) SetLabelsOnTerminatedExecutionExecute(r ApiSetLabelsOnTerminatedExecutionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.SetLabelsOnTerminatedExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.label == nil {
		return localVarReturnValue, nil, reportError("label is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.label
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetLabelsOnTerminatedExecutionsByIdsRequest struct {
	ctx                                      context.Context
	ApiService                               *ExecutionsAPIService
	tenant                                   string
	executionControllerSetLabelsByIdsRequest *ExecutionControllerSetLabelsByIdsRequest
}

// The request containing a list of labels and a list of executions
func (r ApiSetLabelsOnTerminatedExecutionsByIdsRequest) ExecutionControllerSetLabelsByIdsRequest(executionControllerSetLabelsByIdsRequest ExecutionControllerSetLabelsByIdsRequest) ApiSetLabelsOnTerminatedExecutionsByIdsRequest {
	r.executionControllerSetLabelsByIdsRequest = &executionControllerSetLabelsByIdsRequest
	return r
}

func (r ApiSetLabelsOnTerminatedExecutionsByIdsRequest) Execute() (*BulkResponse, *http.Response, error) {
	return r.ApiService.SetLabelsOnTerminatedExecutionsByIdsExecute(r)
}

/*
SetLabelsOnTerminatedExecutionsByIds Set labels on a list of executions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiSetLabelsOnTerminatedExecutionsByIdsRequest
*/
func (a *ExecutionsAPIService) SetLabelsOnTerminatedExecutionsByIds(ctx context.Context, tenant string) ApiSetLabelsOnTerminatedExecutionsByIdsRequest {
	return ApiSetLabelsOnTerminatedExecutionsByIdsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BulkResponse
func (a *ExecutionsAPIService) SetLabelsOnTerminatedExecutionsByIdsExecute(r ApiSetLabelsOnTerminatedExecutionsByIdsRequest) (*BulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.SetLabelsOnTerminatedExecutionsByIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/labels/by-ids"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.executionControllerSetLabelsByIdsRequest == nil {
		return localVarReturnValue, nil, reportError("executionControllerSetLabelsByIdsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.executionControllerSetLabelsByIdsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v BulkErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetLabelsOnTerminatedExecutionsByQueryRequest struct {
	ctx                context.Context
	ApiService         *ExecutionsAPIService
	tenant             string
	label              *[]Label
	q                  *string
	scope              *[]FlowScope
	namespace          *string
	flowId             *string
	startDate          *time.Time
	endDate            *time.Time
	timeRange          *string
	state              *[]StateType
	labels             *[]string
	triggerExecutionId *string
	childFilter        *ExecutionRepositoryInterfaceChildFilter
}

// The labels to add to the execution
func (r ApiSetLabelsOnTerminatedExecutionsByQueryRequest) Label(label []Label) ApiSetLabelsOnTerminatedExecutionsByQueryRequest {
	r.label = &label
	return r
}

// A string filter
func (r ApiSetLabelsOnTerminatedExecutionsByQueryRequest) Q(q string) ApiSetLabelsOnTerminatedExecutionsByQueryRequest {
	r.q = &q
	return r
}

// The scope of the executions to include
func (r ApiSetLabelsOnTerminatedExecutionsByQueryRequest) Scope(scope []FlowScope) ApiSetLabelsOnTerminatedExecutionsByQueryRequest {
	r.scope = &scope
	return r
}

// A namespace filter prefix
func (r ApiSetLabelsOnTerminatedExecutionsByQueryRequest) Namespace(namespace string) ApiSetLabelsOnTerminatedExecutionsByQueryRequest {
	r.namespace = &namespace
	return r
}

// A flow id filter
func (r ApiSetLabelsOnTerminatedExecutionsByQueryRequest) FlowId(flowId string) ApiSetLabelsOnTerminatedExecutionsByQueryRequest {
	r.flowId = &flowId
	return r
}

// The start datetime
func (r ApiSetLabelsOnTerminatedExecutionsByQueryRequest) StartDate(startDate time.Time) ApiSetLabelsOnTerminatedExecutionsByQueryRequest {
	r.startDate = &startDate
	return r
}

// The end datetime
func (r ApiSetLabelsOnTerminatedExecutionsByQueryRequest) EndDate(endDate time.Time) ApiSetLabelsOnTerminatedExecutionsByQueryRequest {
	r.endDate = &endDate
	return r
}

// A time range filter relative to the current time
func (r ApiSetLabelsOnTerminatedExecutionsByQueryRequest) TimeRange(timeRange string) ApiSetLabelsOnTerminatedExecutionsByQueryRequest {
	r.timeRange = &timeRange
	return r
}

// A state filter
func (r ApiSetLabelsOnTerminatedExecutionsByQueryRequest) State(state []StateType) ApiSetLabelsOnTerminatedExecutionsByQueryRequest {
	r.state = &state
	return r
}

// A labels filter as a list of &#39;key:value&#39;
func (r ApiSetLabelsOnTerminatedExecutionsByQueryRequest) Labels(labels []string) ApiSetLabelsOnTerminatedExecutionsByQueryRequest {
	r.labels = &labels
	return r
}

// The trigger execution id
func (r ApiSetLabelsOnTerminatedExecutionsByQueryRequest) TriggerExecutionId(triggerExecutionId string) ApiSetLabelsOnTerminatedExecutionsByQueryRequest {
	r.triggerExecutionId = &triggerExecutionId
	return r
}

// A execution child filter
func (r ApiSetLabelsOnTerminatedExecutionsByQueryRequest) ChildFilter(childFilter ExecutionRepositoryInterfaceChildFilter) ApiSetLabelsOnTerminatedExecutionsByQueryRequest {
	r.childFilter = &childFilter
	return r
}

func (r ApiSetLabelsOnTerminatedExecutionsByQueryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SetLabelsOnTerminatedExecutionsByQueryExecute(r)
}

/*
SetLabelsOnTerminatedExecutionsByQuery Set label on executions filter by query parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiSetLabelsOnTerminatedExecutionsByQueryRequest
*/
func (a *ExecutionsAPIService) SetLabelsOnTerminatedExecutionsByQuery(ctx context.Context, tenant string) ApiSetLabelsOnTerminatedExecutionsByQueryRequest {
	return ApiSetLabelsOnTerminatedExecutionsByQueryRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ExecutionsAPIService) SetLabelsOnTerminatedExecutionsByQueryExecute(r ApiSetLabelsOnTerminatedExecutionsByQueryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.SetLabelsOnTerminatedExecutionsByQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/labels/by-query"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.label == nil {
		return localVarReturnValue, nil, reportError("label is required and must be specified")
	}

	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "form", "csv")
	}
	if r.namespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "namespace", r.namespace, "form", "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.timeRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeRange", r.timeRange, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "csv")
	}
	if r.labels != nil {
		t := *r.labels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "labels", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "labels", t, "form", "multi")
		}
	}
	if r.triggerExecutionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "triggerExecutionId", r.triggerExecutionId, "form", "")
	}
	if r.childFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "childFilter", r.childFilter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.label
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTriggerExecutionRequest struct {
	ctx        context.Context
	ApiService *ExecutionsAPIService
	namespace  string
	id         string
	wait       *bool
	tenant     string
	labels     *[]string
	revision   *int32
}

// If the server will wait the end of the execution
func (r ApiTriggerExecutionRequest) Wait(wait bool) ApiTriggerExecutionRequest {
	r.wait = &wait
	return r
}

// The labels as a list of &#39;key:value&#39;
func (r ApiTriggerExecutionRequest) Labels(labels []string) ApiTriggerExecutionRequest {
	r.labels = &labels
	return r
}

// The flow revision or latest if null
func (r ApiTriggerExecutionRequest) Revision(revision int32) ApiTriggerExecutionRequest {
	r.revision = &revision
	return r
}

func (r ApiTriggerExecutionRequest) Execute() ([]ExecutionControllerExecutionResponse, *http.Response, error) {
	return r.ApiService.TriggerExecutionExecute(r)
}

/*
TriggerExecution Trigger a new execution for a flow

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param namespace The flow namespace
	@param id The flow id
	@param tenant
	@return ApiTriggerExecutionRequest
*/
func (a *ExecutionsAPIService) TriggerExecution(ctx context.Context, namespace string, id string, tenant string) ApiTriggerExecutionRequest {
	return ApiTriggerExecutionRequest{
		ApiService: a,
		ctx:        ctx,
		namespace:  namespace,
		id:         id,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return []ExecutionControllerExecutionResponse
func (a *ExecutionsAPIService) TriggerExecutionExecute(r ApiTriggerExecutionRequest) ([]ExecutionControllerExecutionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ExecutionControllerExecutionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.TriggerExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/trigger/{namespace}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.wait == nil {
		return localVarReturnValue, nil, reportError("wait is required and must be specified")
	}

	if r.labels != nil {
		t := *r.labels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "labels", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "labels", t, "form", "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "wait", r.wait, "form", "")
	if r.revision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revision", r.revision, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTriggerExecutionByGetWebhookRequest struct {
	ctx        context.Context
	ApiService *ExecutionsAPIService
	namespace  string
	id         string
	key        string
	tenant     string
}

func (r ApiTriggerExecutionByGetWebhookRequest) Execute() (*ExecutionControllerWebhookResponse, *http.Response, error) {
	return r.ApiService.TriggerExecutionByGetWebhookExecute(r)
}

/*
TriggerExecutionByGetWebhook Trigger a new execution by GET webhook trigger

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param namespace The flow namespace
	@param id The flow id
	@param key The webhook trigger uid
	@param tenant
	@return ApiTriggerExecutionByGetWebhookRequest
*/
func (a *ExecutionsAPIService) TriggerExecutionByGetWebhook(ctx context.Context, namespace string, id string, key string, tenant string) ApiTriggerExecutionByGetWebhookRequest {
	return ApiTriggerExecutionByGetWebhookRequest{
		ApiService: a,
		ctx:        ctx,
		namespace:  namespace,
		id:         id,
		key:        key,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return ExecutionControllerWebhookResponse
func (a *ExecutionsAPIService) TriggerExecutionByGetWebhookExecute(r ApiTriggerExecutionByGetWebhookRequest) (*ExecutionControllerWebhookResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExecutionControllerWebhookResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.TriggerExecutionByGetWebhook")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/webhook/{namespace}/{id}/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTriggerExecutionByPostWebhookRequest struct {
	ctx        context.Context
	ApiService *ExecutionsAPIService
	namespace  string
	id         string
	key        string
	tenant     string
}

func (r ApiTriggerExecutionByPostWebhookRequest) Execute() (*ExecutionControllerWebhookResponse, *http.Response, error) {
	return r.ApiService.TriggerExecutionByPostWebhookExecute(r)
}

/*
TriggerExecutionByPostWebhook Trigger a new execution by POST webhook trigger

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param namespace The flow namespace
	@param id The flow id
	@param key The webhook trigger uid
	@param tenant
	@return ApiTriggerExecutionByPostWebhookRequest
*/
func (a *ExecutionsAPIService) TriggerExecutionByPostWebhook(ctx context.Context, namespace string, id string, key string, tenant string) ApiTriggerExecutionByPostWebhookRequest {
	return ApiTriggerExecutionByPostWebhookRequest{
		ApiService: a,
		ctx:        ctx,
		namespace:  namespace,
		id:         id,
		key:        key,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return ExecutionControllerWebhookResponse
func (a *ExecutionsAPIService) TriggerExecutionByPostWebhookExecute(r ApiTriggerExecutionByPostWebhookRequest) (*ExecutionControllerWebhookResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExecutionControllerWebhookResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.TriggerExecutionByPostWebhook")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/webhook/{namespace}/{id}/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTriggerExecutionByPutWebhookRequest struct {
	ctx        context.Context
	ApiService *ExecutionsAPIService
	namespace  string
	id         string
	key        string
	tenant     string
}

func (r ApiTriggerExecutionByPutWebhookRequest) Execute() (*ExecutionControllerWebhookResponse, *http.Response, error) {
	return r.ApiService.TriggerExecutionByPutWebhookExecute(r)
}

/*
TriggerExecutionByPutWebhook Trigger a new execution by PUT webhook trigger

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param namespace The flow namespace
	@param id The flow id
	@param key The webhook trigger uid
	@param tenant
	@return ApiTriggerExecutionByPutWebhookRequest
*/
func (a *ExecutionsAPIService) TriggerExecutionByPutWebhook(ctx context.Context, namespace string, id string, key string, tenant string) ApiTriggerExecutionByPutWebhookRequest {
	return ApiTriggerExecutionByPutWebhookRequest{
		ApiService: a,
		ctx:        ctx,
		namespace:  namespace,
		id:         id,
		key:        key,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return ExecutionControllerWebhookResponse
func (a *ExecutionsAPIService) TriggerExecutionByPutWebhookExecute(r ApiTriggerExecutionByPutWebhookRequest) (*ExecutionControllerWebhookResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExecutionControllerWebhookResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.TriggerExecutionByPutWebhook")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/webhook/{namespace}/{id}/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnqueueExecutionRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	state       *StateType
	tenant      string
}

// The new state of the execution
func (r ApiUnqueueExecutionRequest) State(state StateType) ApiUnqueueExecutionRequest {
	r.state = &state
	return r
}

func (r ApiUnqueueExecutionRequest) Execute() (*Execution, *http.Response, error) {
	return r.ApiService.UnqueueExecutionExecute(r)
}

/*
UnqueueExecution Unqueue an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiUnqueueExecutionRequest
*/
func (a *ExecutionsAPIService) UnqueueExecution(ctx context.Context, executionId string, tenant string) ApiUnqueueExecutionRequest {
	return ApiUnqueueExecutionRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return Execution
func (a *ExecutionsAPIService) UnqueueExecutionExecute(r ApiUnqueueExecutionRequest) (*Execution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Execution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.UnqueueExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/unqueue"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.state == nil {
		return localVarReturnValue, nil, reportError("state is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnqueueExecutionsByIdsRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	state       *StateType
	tenant      string
	requestBody *[]string
}

// The new state of the unqueued executions
func (r ApiUnqueueExecutionsByIdsRequest) State(state StateType) ApiUnqueueExecutionsByIdsRequest {
	r.state = &state
	return r
}

// The list of executions id
func (r ApiUnqueueExecutionsByIdsRequest) RequestBody(requestBody []string) ApiUnqueueExecutionsByIdsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiUnqueueExecutionsByIdsRequest) Execute() (*BulkResponse, *http.Response, error) {
	return r.ApiService.UnqueueExecutionsByIdsExecute(r)
}

/*
UnqueueExecutionsByIds Unqueue a list of executions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiUnqueueExecutionsByIdsRequest
*/
func (a *ExecutionsAPIService) UnqueueExecutionsByIds(ctx context.Context, tenant string) ApiUnqueueExecutionsByIdsRequest {
	return ApiUnqueueExecutionsByIdsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BulkResponse
func (a *ExecutionsAPIService) UnqueueExecutionsByIdsExecute(r ApiUnqueueExecutionsByIdsRequest) (*BulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.UnqueueExecutionsByIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/unqueue/by-ids"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.state == nil {
		return localVarReturnValue, nil, reportError("state is required and must be specified")
	}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v BulkErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnqueueExecutionsByQueryRequest struct {
	ctx                            context.Context
	ApiService                     *ExecutionsAPIService
	tenant                         string
	deleteExecutionsByQueryRequest *DeleteExecutionsByQueryRequest
	q                              *string
	scope                          *[]FlowScope
	namespace                      *string
	flowId                         *string
	startDate                      *time.Time
	endDate                        *time.Time
	timeRange                      *string
	state                          *[]StateType
	labels                         *[]string
	triggerExecutionId             *string
	childFilter                    *ExecutionRepositoryInterfaceChildFilter
	newState                       *StateType
}

func (r ApiUnqueueExecutionsByQueryRequest) DeleteExecutionsByQueryRequest(deleteExecutionsByQueryRequest DeleteExecutionsByQueryRequest) ApiUnqueueExecutionsByQueryRequest {
	r.deleteExecutionsByQueryRequest = &deleteExecutionsByQueryRequest
	return r
}

// A string filter
func (r ApiUnqueueExecutionsByQueryRequest) Q(q string) ApiUnqueueExecutionsByQueryRequest {
	r.q = &q
	return r
}

// The scope of the executions to include
func (r ApiUnqueueExecutionsByQueryRequest) Scope(scope []FlowScope) ApiUnqueueExecutionsByQueryRequest {
	r.scope = &scope
	return r
}

// A namespace filter prefix
func (r ApiUnqueueExecutionsByQueryRequest) Namespace(namespace string) ApiUnqueueExecutionsByQueryRequest {
	r.namespace = &namespace
	return r
}

// A flow id filter
func (r ApiUnqueueExecutionsByQueryRequest) FlowId(flowId string) ApiUnqueueExecutionsByQueryRequest {
	r.flowId = &flowId
	return r
}

// The start datetime
func (r ApiUnqueueExecutionsByQueryRequest) StartDate(startDate time.Time) ApiUnqueueExecutionsByQueryRequest {
	r.startDate = &startDate
	return r
}

// The end datetime
func (r ApiUnqueueExecutionsByQueryRequest) EndDate(endDate time.Time) ApiUnqueueExecutionsByQueryRequest {
	r.endDate = &endDate
	return r
}

// A time range filter relative to the current time
func (r ApiUnqueueExecutionsByQueryRequest) TimeRange(timeRange string) ApiUnqueueExecutionsByQueryRequest {
	r.timeRange = &timeRange
	return r
}

// A state filter
func (r ApiUnqueueExecutionsByQueryRequest) State(state []StateType) ApiUnqueueExecutionsByQueryRequest {
	r.state = &state
	return r
}

// A labels filter as a list of &#39;key:value&#39;
func (r ApiUnqueueExecutionsByQueryRequest) Labels(labels []string) ApiUnqueueExecutionsByQueryRequest {
	r.labels = &labels
	return r
}

// The trigger execution id
func (r ApiUnqueueExecutionsByQueryRequest) TriggerExecutionId(triggerExecutionId string) ApiUnqueueExecutionsByQueryRequest {
	r.triggerExecutionId = &triggerExecutionId
	return r
}

// A execution child filter
func (r ApiUnqueueExecutionsByQueryRequest) ChildFilter(childFilter ExecutionRepositoryInterfaceChildFilter) ApiUnqueueExecutionsByQueryRequest {
	r.childFilter = &childFilter
	return r
}

// The new state of the unqueued executions
func (r ApiUnqueueExecutionsByQueryRequest) NewState(newState StateType) ApiUnqueueExecutionsByQueryRequest {
	r.newState = &newState
	return r
}

func (r ApiUnqueueExecutionsByQueryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UnqueueExecutionsByQueryExecute(r)
}

/*
UnqueueExecutionsByQuery Unqueue executions filter by query parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiUnqueueExecutionsByQueryRequest
*/
func (a *ExecutionsAPIService) UnqueueExecutionsByQuery(ctx context.Context, tenant string) ApiUnqueueExecutionsByQueryRequest {
	return ApiUnqueueExecutionsByQueryRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ExecutionsAPIService) UnqueueExecutionsByQueryExecute(r ApiUnqueueExecutionsByQueryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.UnqueueExecutionsByQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/unqueue/by-query"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deleteExecutionsByQueryRequest == nil {
		return localVarReturnValue, nil, reportError("deleteExecutionsByQueryRequest is required and must be specified")
	}

	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "form", "csv")
	}
	if r.namespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "namespace", r.namespace, "form", "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.timeRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeRange", r.timeRange, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "csv")
	}
	if r.labels != nil {
		t := *r.labels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "labels", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "labels", t, "form", "multi")
		}
	}
	if r.triggerExecutionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "triggerExecutionId", r.triggerExecutionId, "form", "")
	}
	if r.childFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "childFilter", r.childFilter, "form", "")
	}
	if r.newState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newState", r.newState, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteExecutionsByQueryRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateExecutionStatusRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	status      *StateType
	tenant      string
}

// The new state of the execution
func (r ApiUpdateExecutionStatusRequest) Status(status StateType) ApiUpdateExecutionStatusRequest {
	r.status = &status
	return r
}

func (r ApiUpdateExecutionStatusRequest) Execute() (*Execution, *http.Response, error) {
	return r.ApiService.UpdateExecutionStatusExecute(r)
}

/*
UpdateExecutionStatus Change the state of an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiUpdateExecutionStatusRequest
*/
func (a *ExecutionsAPIService) UpdateExecutionStatus(ctx context.Context, executionId string, tenant string) ApiUpdateExecutionStatusRequest {
	return ApiUpdateExecutionStatusRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return Execution
func (a *ExecutionsAPIService) UpdateExecutionStatusExecute(r ApiUpdateExecutionStatusRequest) (*Execution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Execution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.UpdateExecutionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/change-status"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.status == nil {
		return localVarReturnValue, nil, reportError("status is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateExecutionsStatusByIdsRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	newStatus   *StateType
	tenant      string
	requestBody *[]string
}

// The new state of the executions
func (r ApiUpdateExecutionsStatusByIdsRequest) NewStatus(newStatus StateType) ApiUpdateExecutionsStatusByIdsRequest {
	r.newStatus = &newStatus
	return r
}

// The list of executions id
func (r ApiUpdateExecutionsStatusByIdsRequest) RequestBody(requestBody []string) ApiUpdateExecutionsStatusByIdsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiUpdateExecutionsStatusByIdsRequest) Execute() (*BulkResponse, *http.Response, error) {
	return r.ApiService.UpdateExecutionsStatusByIdsExecute(r)
}

/*
UpdateExecutionsStatusByIds Change executions state by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiUpdateExecutionsStatusByIdsRequest
*/
func (a *ExecutionsAPIService) UpdateExecutionsStatusByIds(ctx context.Context, tenant string) ApiUpdateExecutionsStatusByIdsRequest {
	return ApiUpdateExecutionsStatusByIdsRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BulkResponse
func (a *ExecutionsAPIService) UpdateExecutionsStatusByIdsExecute(r ApiUpdateExecutionsStatusByIdsRequest) (*BulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.UpdateExecutionsStatusByIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/change-status/by-ids"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.newStatus == nil {
		return localVarReturnValue, nil, reportError("newStatus is required and must be specified")
	}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "newStatus", r.newStatus, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v BulkErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateExecutionsStatusByQueryRequest struct {
	ctx                            context.Context
	ApiService                     *ExecutionsAPIService
	newStatus                      *StateType
	tenant                         string
	deleteExecutionsByQueryRequest *DeleteExecutionsByQueryRequest
	q                              *string
	scope                          *[]FlowScope
	namespace                      *string
	flowId                         *string
	startDate                      *time.Time
	endDate                        *time.Time
	timeRange                      *string
	state                          *[]StateType
	labels                         *[]string
	triggerExecutionId             *string
	childFilter                    *ExecutionRepositoryInterfaceChildFilter
}

// The new state of the executions
func (r ApiUpdateExecutionsStatusByQueryRequest) NewStatus(newStatus StateType) ApiUpdateExecutionsStatusByQueryRequest {
	r.newStatus = &newStatus
	return r
}

func (r ApiUpdateExecutionsStatusByQueryRequest) DeleteExecutionsByQueryRequest(deleteExecutionsByQueryRequest DeleteExecutionsByQueryRequest) ApiUpdateExecutionsStatusByQueryRequest {
	r.deleteExecutionsByQueryRequest = &deleteExecutionsByQueryRequest
	return r
}

// A string filter
func (r ApiUpdateExecutionsStatusByQueryRequest) Q(q string) ApiUpdateExecutionsStatusByQueryRequest {
	r.q = &q
	return r
}

// The scope of the executions to include
func (r ApiUpdateExecutionsStatusByQueryRequest) Scope(scope []FlowScope) ApiUpdateExecutionsStatusByQueryRequest {
	r.scope = &scope
	return r
}

// A namespace filter prefix
func (r ApiUpdateExecutionsStatusByQueryRequest) Namespace(namespace string) ApiUpdateExecutionsStatusByQueryRequest {
	r.namespace = &namespace
	return r
}

// A flow id filter
func (r ApiUpdateExecutionsStatusByQueryRequest) FlowId(flowId string) ApiUpdateExecutionsStatusByQueryRequest {
	r.flowId = &flowId
	return r
}

// The start datetime
func (r ApiUpdateExecutionsStatusByQueryRequest) StartDate(startDate time.Time) ApiUpdateExecutionsStatusByQueryRequest {
	r.startDate = &startDate
	return r
}

// The end datetime
func (r ApiUpdateExecutionsStatusByQueryRequest) EndDate(endDate time.Time) ApiUpdateExecutionsStatusByQueryRequest {
	r.endDate = &endDate
	return r
}

// A time range filter relative to the current time
func (r ApiUpdateExecutionsStatusByQueryRequest) TimeRange(timeRange string) ApiUpdateExecutionsStatusByQueryRequest {
	r.timeRange = &timeRange
	return r
}

// A state filter
func (r ApiUpdateExecutionsStatusByQueryRequest) State(state []StateType) ApiUpdateExecutionsStatusByQueryRequest {
	r.state = &state
	return r
}

// A labels filter as a list of &#39;key:value&#39;
func (r ApiUpdateExecutionsStatusByQueryRequest) Labels(labels []string) ApiUpdateExecutionsStatusByQueryRequest {
	r.labels = &labels
	return r
}

// The trigger execution id
func (r ApiUpdateExecutionsStatusByQueryRequest) TriggerExecutionId(triggerExecutionId string) ApiUpdateExecutionsStatusByQueryRequest {
	r.triggerExecutionId = &triggerExecutionId
	return r
}

// A execution child filter
func (r ApiUpdateExecutionsStatusByQueryRequest) ChildFilter(childFilter ExecutionRepositoryInterfaceChildFilter) ApiUpdateExecutionsStatusByQueryRequest {
	r.childFilter = &childFilter
	return r
}

func (r ApiUpdateExecutionsStatusByQueryRequest) Execute() (*BulkResponse, *http.Response, error) {
	return r.ApiService.UpdateExecutionsStatusByQueryExecute(r)
}

/*
UpdateExecutionsStatusByQuery Change executions state by query parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenant
	@return ApiUpdateExecutionsStatusByQueryRequest
*/
func (a *ExecutionsAPIService) UpdateExecutionsStatusByQuery(ctx context.Context, tenant string) ApiUpdateExecutionsStatusByQueryRequest {
	return ApiUpdateExecutionsStatusByQueryRequest{
		ApiService: a,
		ctx:        ctx,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return BulkResponse
func (a *ExecutionsAPIService) UpdateExecutionsStatusByQueryExecute(r ApiUpdateExecutionsStatusByQueryRequest) (*BulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.UpdateExecutionsStatusByQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/change-status/by-query"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.newStatus == nil {
		return localVarReturnValue, nil, reportError("newStatus is required and must be specified")
	}
	if r.deleteExecutionsByQueryRequest == nil {
		return localVarReturnValue, nil, reportError("deleteExecutionsByQueryRequest is required and must be specified")
	}

	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "form", "csv")
	}
	if r.namespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "namespace", r.namespace, "form", "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.timeRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeRange", r.timeRange, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "csv")
	}
	if r.labels != nil {
		t := *r.labels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "labels", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "labels", t, "form", "multi")
		}
	}
	if r.triggerExecutionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "triggerExecutionId", r.triggerExecutionId, "form", "")
	}
	if r.childFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "childFilter", r.childFilter, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "newStatus", r.newStatus, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteExecutionsByQueryRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v BulkErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTaskRunStateRequest struct {
	ctx                             context.Context
	ApiService                      *ExecutionsAPIService
	executionId                     string
	tenant                          string
	executionControllerStateRequest *ExecutionControllerStateRequest
}

// the taskRun id and state to apply
func (r ApiUpdateTaskRunStateRequest) ExecutionControllerStateRequest(executionControllerStateRequest ExecutionControllerStateRequest) ApiUpdateTaskRunStateRequest {
	r.executionControllerStateRequest = &executionControllerStateRequest
	return r
}

func (r ApiUpdateTaskRunStateRequest) Execute() (*Execution, *http.Response, error) {
	return r.ApiService.UpdateTaskRunStateExecute(r)
}

/*
UpdateTaskRunState Change state for a taskrun in an execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiUpdateTaskRunStateRequest
*/
func (a *ExecutionsAPIService) UpdateTaskRunState(ctx context.Context, executionId string, tenant string) ApiUpdateTaskRunStateRequest {
	return ApiUpdateTaskRunStateRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return Execution
func (a *ExecutionsAPIService) UpdateTaskRunStateExecute(r ApiUpdateTaskRunStateRequest) (*Execution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Execution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.UpdateTaskRunState")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/state"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.executionControllerStateRequest == nil {
		return localVarReturnValue, nil, reportError("executionControllerStateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.executionControllerStateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateNewExecutionInputsRequest struct {
	ctx        context.Context
	ApiService *ExecutionsAPIService
	namespace  string
	id         string
	labels     *[]string
	tenant     string
	revision   *int32
}

// The labels as a list of &#39;key:value&#39;
func (r ApiValidateNewExecutionInputsRequest) Labels(labels []string) ApiValidateNewExecutionInputsRequest {
	r.labels = &labels
	return r
}

// The flow revision or latest if null
func (r ApiValidateNewExecutionInputsRequest) Revision(revision int32) ApiValidateNewExecutionInputsRequest {
	r.revision = &revision
	return r
}

func (r ApiValidateNewExecutionInputsRequest) Execute() ([]ExecutionControllerApiValidateExecutionInputsResponse, *http.Response, error) {
	return r.ApiService.ValidateNewExecutionInputsExecute(r)
}

/*
ValidateNewExecutionInputs Validate the creation of a new execution for a flow

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param namespace The flow namespace
	@param id The flow id
	@param tenant
	@return ApiValidateNewExecutionInputsRequest
*/
func (a *ExecutionsAPIService) ValidateNewExecutionInputs(ctx context.Context, namespace string, id string, tenant string) ApiValidateNewExecutionInputsRequest {
	return ApiValidateNewExecutionInputsRequest{
		ApiService: a,
		ctx:        ctx,
		namespace:  namespace,
		id:         id,
		tenant:     tenant,
	}
}

// Execute executes the request
//
//	@return []ExecutionControllerApiValidateExecutionInputsResponse
func (a *ExecutionsAPIService) ValidateNewExecutionInputsExecute(r ApiValidateNewExecutionInputsRequest) ([]ExecutionControllerApiValidateExecutionInputsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ExecutionControllerApiValidateExecutionInputsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ValidateNewExecutionInputs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{namespace}/{id}/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.labels == nil {
		return localVarReturnValue, nil, reportError("labels is required and must be specified")
	}

	{
		t := *r.labels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "labels", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "labels", t, "form", "multi")
		}
	}
	if r.revision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revision", r.revision, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateResumeExecutionInputsRequest struct {
	ctx         context.Context
	ApiService  *ExecutionsAPIService
	executionId string
	tenant      string
}

func (r ApiValidateResumeExecutionInputsRequest) Execute() ([]ExecutionControllerApiValidateExecutionInputsResponse, *http.Response, error) {
	return r.ApiService.ValidateResumeExecutionInputsExecute(r)
}

/*
ValidateResumeExecutionInputs Validate inputs to resume a paused execution.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId The execution id
	@param tenant
	@return ApiValidateResumeExecutionInputsRequest
*/
func (a *ExecutionsAPIService) ValidateResumeExecutionInputs(ctx context.Context, executionId string, tenant string) ApiValidateResumeExecutionInputsRequest {
	return ApiValidateResumeExecutionInputsRequest{
		ApiService:  a,
		ctx:         ctx,
		executionId: executionId,
		tenant:      tenant,
	}
}

// Execute executes the request
//
//	@return []ExecutionControllerApiValidateExecutionInputsResponse
func (a *ExecutionsAPIService) ValidateResumeExecutionInputsExecute(r ApiValidateResumeExecutionInputsRequest) ([]ExecutionControllerApiValidateExecutionInputsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ExecutionControllerApiValidateExecutionInputsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionsAPIService.ValidateResumeExecutionInputs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{tenant}/executions/{executionId}/resume/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", url.PathEscape(parameterValueToString(r.tenant, "tenant")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
