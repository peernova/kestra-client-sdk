/*
 * Kestra EE
 * All API operations, except for Superadmin-only endpoints, require a tenant identifier in the HTTP path.<br/> Endpoints designated as Superadmin-only are not tenant-scoped.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package io.kestra.sdk.api;

import com.fasterxml.jackson.core.type.TypeReference;

import io.kestra.sdk.internal.ApiException;
import io.kestra.sdk.internal.ApiClient;
import io.kestra.sdk.internal.BaseApi;
import io.kestra.sdk.internal.Configuration;
import io.kestra.sdk.internal.Pair;

import io.kestra.sdk.model.AppsControllerApiBulkImportResponse;
import io.kestra.sdk.model.BulkResponse;
import io.kestra.sdk.model.DeleteExecutionsByQueryRequest;
import java.io.File;
import io.kestra.sdk.model.Flow;
import io.kestra.sdk.model.FlowControllerTaskValidationType;
import io.kestra.sdk.model.FlowGraph;
import io.kestra.sdk.model.FlowInterface;
import io.kestra.sdk.model.FlowScope;
import io.kestra.sdk.model.FlowTopologyGraph;
import io.kestra.sdk.model.FlowWithSource;
import io.kestra.sdk.model.IdWithNamespace;
import io.kestra.sdk.model.PagedResultsFlow;
import io.kestra.sdk.model.PagedResultsSearchResultFlow;
import io.kestra.sdk.model.QueryFilter;
import io.kestra.sdk.model.Task;
import io.kestra.sdk.model.UpdateFlow200Response;
import io.kestra.sdk.model.UpdateFlowsInNamespaceFromJson200Response;
import io.kestra.sdk.model.ValidateConstraintViolation;


import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.StringJoiner;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.16.0-SNAPSHOT")
public class FlowsApi extends BaseApi {

  public FlowsApi() {
    super(Configuration.getDefaultApiClient());
  }

  public FlowsApi(ApiClient apiClient) {
    super(apiClient);
  }

  /**
   *     Import apps as a ZIP archive of yaml sources or a multi-objects YAML file.     When sending a Yaml that contains one or more apps, a list of index is returned.     When sending a ZIP archive, a list of files that couldn&#39;t be imported is returned. 
   * 
   * @param tenant  (required)
   * @param fileUpload The file to import, can be a ZIP archive or a multi-objects YAML file (optional)
   * @return AppsControllerApiBulkImportResponse
   * @throws ApiException if fails to make API call
   */
  public AppsControllerApiBulkImportResponse bulkImportApps(@javax.annotation.Nonnull String tenant, @javax.annotation.Nullable File fileUpload) throws ApiException {
    return this.bulkImportApps(tenant, fileUpload, Collections.emptyMap());
  }


  /**
   *     Import apps as a ZIP archive of yaml sources or a multi-objects YAML file.     When sending a Yaml that contains one or more apps, a list of index is returned.     When sending a ZIP archive, a list of files that couldn&#39;t be imported is returned. 
   * 
   * @param tenant  (required)
   * @param fileUpload The file to import, can be a ZIP archive or a multi-objects YAML file (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return AppsControllerApiBulkImportResponse
   * @throws ApiException if fails to make API call
   */
  public AppsControllerApiBulkImportResponse bulkImportApps(@javax.annotation.Nonnull String tenant, @javax.annotation.Nullable File fileUpload, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling bulkImportApps");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/apps/import"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    if (fileUpload != null)
      localVarFormParams.put("fileUpload", fileUpload);

    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "multipart/form-data"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<AppsControllerApiBulkImportResponse> localVarReturnType = new TypeReference<AppsControllerApiBulkImportResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Update from multiples yaml sources
   * All flow will be created / updated for this namespace. Flow that already created but not in &#x60;flows&#x60; will be deleted if the query delete is &#x60;true&#x60;
   * @param delete If missing flow should be deleted (required)
   * @param allowNamespaceChild If namespace child should are allowed to be updated (required)
   * @param tenant  (required)
   * @param namespace The namespace where to update flows (optional)
   * @param body A list of flows source code splitted with \&quot;---\&quot; (optional)
   * @return List&lt;FlowInterface&gt;
   * @throws ApiException if fails to make API call
   */
  public List<FlowInterface> bulkUpdateFlows(@javax.annotation.Nonnull Boolean delete, @javax.annotation.Nonnull Boolean allowNamespaceChild, @javax.annotation.Nonnull String tenant, @javax.annotation.Nullable String namespace, @javax.annotation.Nullable String body) throws ApiException {
    return this.bulkUpdateFlows(delete, allowNamespaceChild, tenant, namespace, body, Collections.emptyMap());
  }


  /**
   * Update from multiples yaml sources
   * All flow will be created / updated for this namespace. Flow that already created but not in &#x60;flows&#x60; will be deleted if the query delete is &#x60;true&#x60;
   * @param delete If missing flow should be deleted (required)
   * @param allowNamespaceChild If namespace child should are allowed to be updated (required)
   * @param tenant  (required)
   * @param namespace The namespace where to update flows (optional)
   * @param body A list of flows source code splitted with \&quot;---\&quot; (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;FlowInterface&gt;
   * @throws ApiException if fails to make API call
   */
  public List<FlowInterface> bulkUpdateFlows(@javax.annotation.Nonnull Boolean delete, @javax.annotation.Nonnull Boolean allowNamespaceChild, @javax.annotation.Nonnull String tenant, @javax.annotation.Nullable String namespace, @javax.annotation.Nullable String body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'delete' is set
    if (delete == null) {
      throw new ApiException(400, "Missing the required parameter 'delete' when calling bulkUpdateFlows");
    }
    
    // verify the required parameter 'allowNamespaceChild' is set
    if (allowNamespaceChild == null) {
      throw new ApiException(400, "Missing the required parameter 'allowNamespaceChild' when calling bulkUpdateFlows");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling bulkUpdateFlows");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/bulk"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("delete", delete));
    localVarQueryParams.addAll(apiClient.parameterToPair("namespace", namespace));
    localVarQueryParams.addAll(apiClient.parameterToPair("allowNamespaceChild", allowNamespaceChild));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/x-yaml"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<List<FlowInterface>> localVarReturnType = new TypeReference<List<FlowInterface>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create a flow from yaml source
   * 
   * @param tenant  (required)
   * @param body The flow source code (required)
   * @return FlowWithSource
   * @throws ApiException if fails to make API call
   */
  public FlowWithSource createFlow(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull String body) throws ApiException {
    return this.createFlow(tenant, body, Collections.emptyMap());
  }


  /**
   * Create a flow from yaml source
   * 
   * @param tenant  (required)
   * @param body The flow source code (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return FlowWithSource
   * @throws ApiException if fails to make API call
   */
  public FlowWithSource createFlow(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull String body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling createFlow");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling createFlow");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/x-yaml"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<FlowWithSource> localVarReturnType = new TypeReference<FlowWithSource>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Delete a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param tenant  (required)
   * @throws ApiException if fails to make API call
   */
  public void deleteFlow(@javax.annotation.Nonnull String namespace, @javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tenant) throws ApiException {
    this.deleteFlow(namespace, id, tenant, Collections.emptyMap());
  }


  /**
   * Delete a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param tenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @throws ApiException if fails to make API call
   */
  public void deleteFlow(@javax.annotation.Nonnull String namespace, @javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling deleteFlow");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling deleteFlow");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling deleteFlow");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}/{id}"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        null
    );
  }

  /**
   * Delete flows by their IDs.
   * 
   * @param tenant  (required)
   * @param idWithNamespace A list of tuple flow ID and namespace as flow identifiers (required)
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse deleteFlowsByIds(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull List<IdWithNamespace> idWithNamespace) throws ApiException {
    return this.deleteFlowsByIds(tenant, idWithNamespace, Collections.emptyMap());
  }


  /**
   * Delete flows by their IDs.
   * 
   * @param tenant  (required)
   * @param idWithNamespace A list of tuple flow ID and namespace as flow identifiers (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse deleteFlowsByIds(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull List<IdWithNamespace> idWithNamespace, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = idWithNamespace;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling deleteFlowsByIds");
    }
    
    // verify the required parameter 'idWithNamespace' is set
    if (idWithNamespace == null) {
      throw new ApiException(400, "Missing the required parameter 'idWithNamespace' when calling deleteFlowsByIds");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/delete/by-ids"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<BulkResponse> localVarReturnType = new TypeReference<BulkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Delete flows returned by the query parameters.
   * 
   * @param tenant  (required)
   * @param deleteExecutionsByQueryRequest  (required)
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse deleteFlowsByQuery(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull DeleteExecutionsByQueryRequest deleteExecutionsByQueryRequest, @javax.annotation.Nullable String q, @javax.annotation.Nullable List<FlowScope> scope, @javax.annotation.Nullable String namespace, @javax.annotation.Nullable List<String> labels) throws ApiException {
    return this.deleteFlowsByQuery(tenant, deleteExecutionsByQueryRequest, q, scope, namespace, labels, Collections.emptyMap());
  }


  /**
   * Delete flows returned by the query parameters.
   * 
   * @param tenant  (required)
   * @param deleteExecutionsByQueryRequest  (required)
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse deleteFlowsByQuery(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull DeleteExecutionsByQueryRequest deleteExecutionsByQueryRequest, @javax.annotation.Nullable String q, @javax.annotation.Nullable List<FlowScope> scope, @javax.annotation.Nullable String namespace, @javax.annotation.Nullable List<String> labels, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = deleteExecutionsByQueryRequest;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling deleteFlowsByQuery");
    }
    
    // verify the required parameter 'deleteExecutionsByQueryRequest' is set
    if (deleteExecutionsByQueryRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'deleteExecutionsByQueryRequest' when calling deleteFlowsByQuery");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/delete/by-query"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("csv", "scope", scope));
    localVarQueryParams.addAll(apiClient.parameterToPair("namespace", namespace));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "labels", labels));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<BulkResponse> localVarReturnType = new TypeReference<BulkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Disable flows by their IDs.
   * 
   * @param tenant  (required)
   * @param idWithNamespace A list of tuple flow ID and namespace as flow identifiers (required)
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse disableFlowsByIds(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull List<IdWithNamespace> idWithNamespace) throws ApiException {
    return this.disableFlowsByIds(tenant, idWithNamespace, Collections.emptyMap());
  }


  /**
   * Disable flows by their IDs.
   * 
   * @param tenant  (required)
   * @param idWithNamespace A list of tuple flow ID and namespace as flow identifiers (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse disableFlowsByIds(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull List<IdWithNamespace> idWithNamespace, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = idWithNamespace;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling disableFlowsByIds");
    }
    
    // verify the required parameter 'idWithNamespace' is set
    if (idWithNamespace == null) {
      throw new ApiException(400, "Missing the required parameter 'idWithNamespace' when calling disableFlowsByIds");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/disable/by-ids"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<BulkResponse> localVarReturnType = new TypeReference<BulkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Disable flows returned by the query parameters.
   * 
   * @param tenant  (required)
   * @param deleteExecutionsByQueryRequest  (required)
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse disableFlowsByQuery(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull DeleteExecutionsByQueryRequest deleteExecutionsByQueryRequest, @javax.annotation.Nullable String q, @javax.annotation.Nullable List<FlowScope> scope, @javax.annotation.Nullable String namespace, @javax.annotation.Nullable List<String> labels) throws ApiException {
    return this.disableFlowsByQuery(tenant, deleteExecutionsByQueryRequest, q, scope, namespace, labels, Collections.emptyMap());
  }


  /**
   * Disable flows returned by the query parameters.
   * 
   * @param tenant  (required)
   * @param deleteExecutionsByQueryRequest  (required)
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse disableFlowsByQuery(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull DeleteExecutionsByQueryRequest deleteExecutionsByQueryRequest, @javax.annotation.Nullable String q, @javax.annotation.Nullable List<FlowScope> scope, @javax.annotation.Nullable String namespace, @javax.annotation.Nullable List<String> labels, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = deleteExecutionsByQueryRequest;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling disableFlowsByQuery");
    }
    
    // verify the required parameter 'deleteExecutionsByQueryRequest' is set
    if (deleteExecutionsByQueryRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'deleteExecutionsByQueryRequest' when calling disableFlowsByQuery");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/disable/by-query"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("csv", "scope", scope));
    localVarQueryParams.addAll(apiClient.parameterToPair("namespace", namespace));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "labels", labels));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<BulkResponse> localVarReturnType = new TypeReference<BulkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Enable flows by their IDs.
   * 
   * @param tenant  (required)
   * @param idWithNamespace A list of tuple flow ID and namespace as flow identifiers (required)
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse enableFlowsByIds(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull List<IdWithNamespace> idWithNamespace) throws ApiException {
    return this.enableFlowsByIds(tenant, idWithNamespace, Collections.emptyMap());
  }


  /**
   * Enable flows by their IDs.
   * 
   * @param tenant  (required)
   * @param idWithNamespace A list of tuple flow ID and namespace as flow identifiers (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse enableFlowsByIds(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull List<IdWithNamespace> idWithNamespace, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = idWithNamespace;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling enableFlowsByIds");
    }
    
    // verify the required parameter 'idWithNamespace' is set
    if (idWithNamespace == null) {
      throw new ApiException(400, "Missing the required parameter 'idWithNamespace' when calling enableFlowsByIds");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/enable/by-ids"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<BulkResponse> localVarReturnType = new TypeReference<BulkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Enable flows returned by the query parameters.
   * 
   * @param tenant  (required)
   * @param deleteExecutionsByQueryRequest  (required)
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse enableFlowsByQuery(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull DeleteExecutionsByQueryRequest deleteExecutionsByQueryRequest, @javax.annotation.Nullable String q, @javax.annotation.Nullable List<FlowScope> scope, @javax.annotation.Nullable String namespace, @javax.annotation.Nullable List<String> labels) throws ApiException {
    return this.enableFlowsByQuery(tenant, deleteExecutionsByQueryRequest, q, scope, namespace, labels, Collections.emptyMap());
  }


  /**
   * Enable flows returned by the query parameters.
   * 
   * @param tenant  (required)
   * @param deleteExecutionsByQueryRequest  (required)
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return BulkResponse
   * @throws ApiException if fails to make API call
   */
  public BulkResponse enableFlowsByQuery(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull DeleteExecutionsByQueryRequest deleteExecutionsByQueryRequest, @javax.annotation.Nullable String q, @javax.annotation.Nullable List<FlowScope> scope, @javax.annotation.Nullable String namespace, @javax.annotation.Nullable List<String> labels, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = deleteExecutionsByQueryRequest;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling enableFlowsByQuery");
    }
    
    // verify the required parameter 'deleteExecutionsByQueryRequest' is set
    if (deleteExecutionsByQueryRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'deleteExecutionsByQueryRequest' when calling enableFlowsByQuery");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/enable/by-query"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("csv", "scope", scope));
    localVarQueryParams.addAll(apiClient.parameterToPair("namespace", namespace));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "labels", labels));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<BulkResponse> localVarReturnType = new TypeReference<BulkResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Export flows as a ZIP archive of yaml sources.
   * 
   * @param tenant  (required)
   * @param idWithNamespace A list of tuple flow ID and namespace as flow identifiers (required)
   * @return byte[]
   * @throws ApiException if fails to make API call
   */
  public byte[] exportFlowsByIds(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull List<IdWithNamespace> idWithNamespace) throws ApiException {
    return this.exportFlowsByIds(tenant, idWithNamespace, Collections.emptyMap());
  }


  /**
   * Export flows as a ZIP archive of yaml sources.
   * 
   * @param tenant  (required)
   * @param idWithNamespace A list of tuple flow ID and namespace as flow identifiers (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return byte[]
   * @throws ApiException if fails to make API call
   */
  public byte[] exportFlowsByIds(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull List<IdWithNamespace> idWithNamespace, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = idWithNamespace;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling exportFlowsByIds");
    }
    
    // verify the required parameter 'idWithNamespace' is set
    if (idWithNamespace == null) {
      throw new ApiException(400, "Missing the required parameter 'idWithNamespace' when calling exportFlowsByIds");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/export/by-ids"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/octet-stream"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<byte[]> localVarReturnType = new TypeReference<byte[]>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Export flows as a ZIP archive of yaml sources.
   * 
   * @param tenant  (required)
   * @param filters Filters (optional)
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @return byte[]
   * @throws ApiException if fails to make API call
   */
  public byte[] exportFlowsByQuery(@javax.annotation.Nonnull String tenant, @javax.annotation.Nullable List<QueryFilter> filters, @javax.annotation.Nullable String q, @javax.annotation.Nullable List<FlowScope> scope, @javax.annotation.Nullable String namespace, @javax.annotation.Nullable List<String> labels) throws ApiException {
    return this.exportFlowsByQuery(tenant, filters, q, scope, namespace, labels, Collections.emptyMap());
  }


  /**
   * Export flows as a ZIP archive of yaml sources.
   * 
   * @param tenant  (required)
   * @param filters Filters (optional)
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return byte[]
   * @throws ApiException if fails to make API call
   */
  public byte[] exportFlowsByQuery(@javax.annotation.Nonnull String tenant, @javax.annotation.Nullable List<QueryFilter> filters, @javax.annotation.Nullable String q, @javax.annotation.Nullable List<FlowScope> scope, @javax.annotation.Nullable String namespace, @javax.annotation.Nullable List<String> labels, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling exportFlowsByQuery");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/export/by-query"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("csv", "filters", filters));
    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("csv", "scope", scope));
    localVarQueryParams.addAll(apiClient.parameterToPair("namespace", namespace));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "labels", labels));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/octet-stream"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<byte[]> localVarReturnType = new TypeReference<byte[]>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Generate a graph for a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param tenant  (required)
   * @param revision The flow revision (optional)
   * @param subflows The subflow tasks to display (optional)
   * @return FlowGraph
   * @throws ApiException if fails to make API call
   */
  public FlowGraph generateFlowGraph(@javax.annotation.Nonnull String namespace, @javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tenant, @javax.annotation.Nullable Integer revision, @javax.annotation.Nullable List<String> subflows) throws ApiException {
    return this.generateFlowGraph(namespace, id, tenant, revision, subflows, Collections.emptyMap());
  }


  /**
   * Generate a graph for a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param tenant  (required)
   * @param revision The flow revision (optional)
   * @param subflows The subflow tasks to display (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return FlowGraph
   * @throws ApiException if fails to make API call
   */
  public FlowGraph generateFlowGraph(@javax.annotation.Nonnull String namespace, @javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tenant, @javax.annotation.Nullable Integer revision, @javax.annotation.Nullable List<String> subflows, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling generateFlowGraph");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling generateFlowGraph");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling generateFlowGraph");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}/{id}/graph"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("revision", revision));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("csv", "subflows", subflows));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<FlowGraph> localVarReturnType = new TypeReference<FlowGraph>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Generate a graph for a flow source
   * 
   * @param tenant  (required)
   * @param body The flow source code (required)
   * @param subflows The subflow tasks to display (optional)
   * @return FlowGraph
   * @throws ApiException if fails to make API call
   */
  public FlowGraph generateFlowGraphFromSource(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull String body, @javax.annotation.Nullable List<String> subflows) throws ApiException {
    return this.generateFlowGraphFromSource(tenant, body, subflows, Collections.emptyMap());
  }


  /**
   * Generate a graph for a flow source
   * 
   * @param tenant  (required)
   * @param body The flow source code (required)
   * @param subflows The subflow tasks to display (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return FlowGraph
   * @throws ApiException if fails to make API call
   */
  public FlowGraph generateFlowGraphFromSource(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull String body, @javax.annotation.Nullable List<String> subflows, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling generateFlowGraphFromSource");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling generateFlowGraphFromSource");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/graph"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("csv", "subflows", subflows));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/x-yaml"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<FlowGraph> localVarReturnType = new TypeReference<FlowGraph>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Get a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param source Include the source code (required)
   * @param allowDeleted Get flow even if deleted (required)
   * @param tenant  (required)
   * @param revision Get latest revision by default (optional)
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object getFlow(@javax.annotation.Nonnull String namespace, @javax.annotation.Nonnull String id, @javax.annotation.Nonnull Boolean source, @javax.annotation.Nonnull Boolean allowDeleted, @javax.annotation.Nonnull String tenant, @javax.annotation.Nullable Integer revision) throws ApiException {
    return this.getFlow(namespace, id, source, allowDeleted, tenant, revision, Collections.emptyMap());
  }


  /**
   * Get a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param source Include the source code (required)
   * @param allowDeleted Get flow even if deleted (required)
   * @param tenant  (required)
   * @param revision Get latest revision by default (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object getFlow(@javax.annotation.Nonnull String namespace, @javax.annotation.Nonnull String id, @javax.annotation.Nonnull Boolean source, @javax.annotation.Nonnull Boolean allowDeleted, @javax.annotation.Nonnull String tenant, @javax.annotation.Nullable Integer revision, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling getFlow");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling getFlow");
    }
    
    // verify the required parameter 'source' is set
    if (source == null) {
      throw new ApiException(400, "Missing the required parameter 'source' when calling getFlow");
    }
    
    // verify the required parameter 'allowDeleted' is set
    if (allowDeleted == null) {
      throw new ApiException(400, "Missing the required parameter 'allowDeleted' when calling getFlow");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling getFlow");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}/{id}"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("source", source));
    localVarQueryParams.addAll(apiClient.parameterToPair("revision", revision));
    localVarQueryParams.addAll(apiClient.parameterToPair("allowDeleted", allowDeleted));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<Object> localVarReturnType = new TypeReference<Object>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Get flow dependencies
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param destinationOnly If true, list only destination dependencies, otherwise list also source dependencies (required)
   * @param expandAll If true, expand all dependencies recursively (required)
   * @param tenant  (required)
   * @return FlowTopologyGraph
   * @throws ApiException if fails to make API call
   */
  public FlowTopologyGraph getFlowDependencies(@javax.annotation.Nonnull String namespace, @javax.annotation.Nonnull String id, @javax.annotation.Nonnull Boolean destinationOnly, @javax.annotation.Nonnull Boolean expandAll, @javax.annotation.Nonnull String tenant) throws ApiException {
    return this.getFlowDependencies(namespace, id, destinationOnly, expandAll, tenant, Collections.emptyMap());
  }


  /**
   * Get flow dependencies
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param destinationOnly If true, list only destination dependencies, otherwise list also source dependencies (required)
   * @param expandAll If true, expand all dependencies recursively (required)
   * @param tenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return FlowTopologyGraph
   * @throws ApiException if fails to make API call
   */
  public FlowTopologyGraph getFlowDependencies(@javax.annotation.Nonnull String namespace, @javax.annotation.Nonnull String id, @javax.annotation.Nonnull Boolean destinationOnly, @javax.annotation.Nonnull Boolean expandAll, @javax.annotation.Nonnull String tenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling getFlowDependencies");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling getFlowDependencies");
    }
    
    // verify the required parameter 'destinationOnly' is set
    if (destinationOnly == null) {
      throw new ApiException(400, "Missing the required parameter 'destinationOnly' when calling getFlowDependencies");
    }
    
    // verify the required parameter 'expandAll' is set
    if (expandAll == null) {
      throw new ApiException(400, "Missing the required parameter 'expandAll' when calling getFlowDependencies");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling getFlowDependencies");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}/{id}/dependencies"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("destinationOnly", destinationOnly));
    localVarQueryParams.addAll(apiClient.parameterToPair("expandAll", expandAll));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<FlowTopologyGraph> localVarReturnType = new TypeReference<FlowTopologyGraph>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Retrieve flow dependencies
   * 
   * @param namespace The flow namespace (required)
   * @param destinationOnly if true, list only destination dependencies, otherwise list also source dependencies (required)
   * @param tenant  (required)
   * @return FlowTopologyGraph
   * @throws ApiException if fails to make API call
   */
  public FlowTopologyGraph getFlowDependenciesFromNamespace(@javax.annotation.Nonnull String namespace, @javax.annotation.Nonnull Boolean destinationOnly, @javax.annotation.Nonnull String tenant) throws ApiException {
    return this.getFlowDependenciesFromNamespace(namespace, destinationOnly, tenant, Collections.emptyMap());
  }


  /**
   * Retrieve flow dependencies
   * 
   * @param namespace The flow namespace (required)
   * @param destinationOnly if true, list only destination dependencies, otherwise list also source dependencies (required)
   * @param tenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return FlowTopologyGraph
   * @throws ApiException if fails to make API call
   */
  public FlowTopologyGraph getFlowDependenciesFromNamespace(@javax.annotation.Nonnull String namespace, @javax.annotation.Nonnull Boolean destinationOnly, @javax.annotation.Nonnull String tenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling getFlowDependenciesFromNamespace");
    }
    
    // verify the required parameter 'destinationOnly' is set
    if (destinationOnly == null) {
      throw new ApiException(400, "Missing the required parameter 'destinationOnly' when calling getFlowDependenciesFromNamespace");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling getFlowDependenciesFromNamespace");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/namespaces/{namespace}/dependencies"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("destinationOnly", destinationOnly));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<FlowTopologyGraph> localVarReturnType = new TypeReference<FlowTopologyGraph>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Get a flow task
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param taskId The task id (required)
   * @param tenant  (required)
   * @param revision The flow revision (optional)
   * @return Task
   * @throws ApiException if fails to make API call
   */
  public Task getTaskFromFlow(@javax.annotation.Nonnull String namespace, @javax.annotation.Nonnull String id, @javax.annotation.Nonnull String taskId, @javax.annotation.Nonnull String tenant, @javax.annotation.Nullable Integer revision) throws ApiException {
    return this.getTaskFromFlow(namespace, id, taskId, tenant, revision, Collections.emptyMap());
  }


  /**
   * Get a flow task
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param taskId The task id (required)
   * @param tenant  (required)
   * @param revision The flow revision (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return Task
   * @throws ApiException if fails to make API call
   */
  public Task getTaskFromFlow(@javax.annotation.Nonnull String namespace, @javax.annotation.Nonnull String id, @javax.annotation.Nonnull String taskId, @javax.annotation.Nonnull String tenant, @javax.annotation.Nullable Integer revision, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling getTaskFromFlow");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling getTaskFromFlow");
    }
    
    // verify the required parameter 'taskId' is set
    if (taskId == null) {
      throw new ApiException(400, "Missing the required parameter 'taskId' when calling getTaskFromFlow");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling getTaskFromFlow");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}/{id}/tasks/{taskId}"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "taskId" + "\\}", apiClient.escapeString(apiClient.parameterToString(taskId)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("revision", revision));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<Task> localVarReturnType = new TypeReference<Task>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   *     Import flows as a ZIP archive of yaml sources or a multi-objects YAML file.     When sending a Yaml that contains one or more flows, a list of index is returned.     When sending a ZIP archive, a list of files that couldn&#39;t be imported is returned. 
   * 
   * @param tenant  (required)
   * @param fileUpload The file to import, can be a ZIP archive or a multi-objects YAML file (optional)
   * @return List&lt;String&gt;
   * @throws ApiException if fails to make API call
   */
  public List<String> importFlows(@javax.annotation.Nonnull String tenant, @javax.annotation.Nullable File fileUpload) throws ApiException {
    return this.importFlows(tenant, fileUpload, Collections.emptyMap());
  }


  /**
   *     Import flows as a ZIP archive of yaml sources or a multi-objects YAML file.     When sending a Yaml that contains one or more flows, a list of index is returned.     When sending a ZIP archive, a list of files that couldn&#39;t be imported is returned. 
   * 
   * @param tenant  (required)
   * @param fileUpload The file to import, can be a ZIP archive or a multi-objects YAML file (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;String&gt;
   * @throws ApiException if fails to make API call
   */
  public List<String> importFlows(@javax.annotation.Nonnull String tenant, @javax.annotation.Nullable File fileUpload, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling importFlows");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/import"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    if (fileUpload != null)
      localVarFormParams.put("fileUpload", fileUpload);

    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "multipart/form-data"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<List<String>> localVarReturnType = new TypeReference<List<String>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * List all distinct namespaces
   * 
   * @param tenant  (required)
   * @param q A string filter (optional)
   * @return List&lt;String&gt;
   * @throws ApiException if fails to make API call
   */
  public List<String> listDistinctNamespaces(@javax.annotation.Nonnull String tenant, @javax.annotation.Nullable String q) throws ApiException {
    return this.listDistinctNamespaces(tenant, q, Collections.emptyMap());
  }


  /**
   * List all distinct namespaces
   * 
   * @param tenant  (required)
   * @param q A string filter (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;String&gt;
   * @throws ApiException if fails to make API call
   */
  public List<String> listDistinctNamespaces(@javax.annotation.Nonnull String tenant, @javax.annotation.Nullable String q, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling listDistinctNamespaces");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/distinct-namespaces"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<List<String>> localVarReturnType = new TypeReference<List<String>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Get revisions for a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param tenant  (required)
   * @return List&lt;FlowWithSource&gt;
   * @throws ApiException if fails to make API call
   */
  public List<FlowWithSource> listFlowRevisions(@javax.annotation.Nonnull String namespace, @javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tenant) throws ApiException {
    return this.listFlowRevisions(namespace, id, tenant, Collections.emptyMap());
  }


  /**
   * Get revisions for a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param tenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;FlowWithSource&gt;
   * @throws ApiException if fails to make API call
   */
  public List<FlowWithSource> listFlowRevisions(@javax.annotation.Nonnull String namespace, @javax.annotation.Nonnull String id, @javax.annotation.Nonnull String tenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling listFlowRevisions");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling listFlowRevisions");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling listFlowRevisions");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}/{id}/revisions"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<List<FlowWithSource>> localVarReturnType = new TypeReference<List<FlowWithSource>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Retrieve all flows from a given namespace
   * 
   * @param namespace Namespace to filter flows (required)
   * @param tenant  (required)
   * @return List&lt;Flow&gt;
   * @throws ApiException if fails to make API call
   */
  public List<Flow> listFlowsByNamespace(@javax.annotation.Nonnull String namespace, @javax.annotation.Nonnull String tenant) throws ApiException {
    return this.listFlowsByNamespace(namespace, tenant, Collections.emptyMap());
  }


  /**
   * Retrieve all flows from a given namespace
   * 
   * @param namespace Namespace to filter flows (required)
   * @param tenant  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;Flow&gt;
   * @throws ApiException if fails to make API call
   */
  public List<Flow> listFlowsByNamespace(@javax.annotation.Nonnull String namespace, @javax.annotation.Nonnull String tenant, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling listFlowsByNamespace");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling listFlowsByNamespace");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<List<Flow>> localVarReturnType = new TypeReference<List<Flow>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Search for flows
   * 
   * @param page The current page (required)
   * @param size The current page size (required)
   * @param tenant  (required)
   * @param sort The sort of current page (optional)
   * @param filters Filters (optional)
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @return PagedResultsFlow
   * @throws ApiException if fails to make API call
   */
  public PagedResultsFlow searchFlows(@javax.annotation.Nonnull Integer page, @javax.annotation.Nonnull Integer size, @javax.annotation.Nonnull String tenant, @javax.annotation.Nullable List<String> sort, @javax.annotation.Nullable List<QueryFilter> filters, @javax.annotation.Nullable String q, @javax.annotation.Nullable List<FlowScope> scope, @javax.annotation.Nullable String namespace, @javax.annotation.Nullable List<String> labels) throws ApiException {
    return this.searchFlows(page, size, tenant, sort, filters, q, scope, namespace, labels, Collections.emptyMap());
  }


  /**
   * Search for flows
   * 
   * @param page The current page (required)
   * @param size The current page size (required)
   * @param tenant  (required)
   * @param sort The sort of current page (optional)
   * @param filters Filters (optional)
   * @param q A string filter (optional)
   * @param scope The scope of the flows to include (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param labels A labels filter as a list of &#39;key:value&#39; (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return PagedResultsFlow
   * @throws ApiException if fails to make API call
   */
  public PagedResultsFlow searchFlows(@javax.annotation.Nonnull Integer page, @javax.annotation.Nonnull Integer size, @javax.annotation.Nonnull String tenant, @javax.annotation.Nullable List<String> sort, @javax.annotation.Nullable List<QueryFilter> filters, @javax.annotation.Nullable String q, @javax.annotation.Nullable List<FlowScope> scope, @javax.annotation.Nullable String namespace, @javax.annotation.Nullable List<String> labels, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'page' is set
    if (page == null) {
      throw new ApiException(400, "Missing the required parameter 'page' when calling searchFlows");
    }
    
    // verify the required parameter 'size' is set
    if (size == null) {
      throw new ApiException(400, "Missing the required parameter 'size' when calling searchFlows");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling searchFlows");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/search"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
    localVarQueryParams.addAll(apiClient.parameterToPair("size", size));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("csv", "sort", sort));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("csv", "filters", filters));
    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("csv", "scope", scope));
    localVarQueryParams.addAll(apiClient.parameterToPair("namespace", namespace));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "labels", labels));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<PagedResultsFlow> localVarReturnType = new TypeReference<PagedResultsFlow>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Search for flows source code
   * 
   * @param page The current page (required)
   * @param size The current page size (required)
   * @param tenant  (required)
   * @param sort The sort of current page (optional)
   * @param q A string filter (optional)
   * @param namespace A namespace filter prefix (optional)
   * @return PagedResultsSearchResultFlow
   * @throws ApiException if fails to make API call
   */
  public PagedResultsSearchResultFlow searchFlowsBySourceCode(@javax.annotation.Nonnull Integer page, @javax.annotation.Nonnull Integer size, @javax.annotation.Nonnull String tenant, @javax.annotation.Nullable List<String> sort, @javax.annotation.Nullable String q, @javax.annotation.Nullable String namespace) throws ApiException {
    return this.searchFlowsBySourceCode(page, size, tenant, sort, q, namespace, Collections.emptyMap());
  }


  /**
   * Search for flows source code
   * 
   * @param page The current page (required)
   * @param size The current page size (required)
   * @param tenant  (required)
   * @param sort The sort of current page (optional)
   * @param q A string filter (optional)
   * @param namespace A namespace filter prefix (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return PagedResultsSearchResultFlow
   * @throws ApiException if fails to make API call
   */
  public PagedResultsSearchResultFlow searchFlowsBySourceCode(@javax.annotation.Nonnull Integer page, @javax.annotation.Nonnull Integer size, @javax.annotation.Nonnull String tenant, @javax.annotation.Nullable List<String> sort, @javax.annotation.Nullable String q, @javax.annotation.Nullable String namespace, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'page' is set
    if (page == null) {
      throw new ApiException(400, "Missing the required parameter 'page' when calling searchFlowsBySourceCode");
    }
    
    // verify the required parameter 'size' is set
    if (size == null) {
      throw new ApiException(400, "Missing the required parameter 'size' when calling searchFlowsBySourceCode");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling searchFlowsBySourceCode");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/source"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
    localVarQueryParams.addAll(apiClient.parameterToPair("size", size));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("csv", "sort", sort));
    localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
    localVarQueryParams.addAll(apiClient.parameterToPair("namespace", namespace));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<PagedResultsSearchResultFlow> localVarReturnType = new TypeReference<PagedResultsSearchResultFlow>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Update a flow
   * 
   * @param id The flow id (required)
   * @param namespace The flow namespace (required)
   * @param tenant  (required)
   * @param body The flow source code (required)
   * @return UpdateFlow200Response
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public UpdateFlow200Response updateFlow(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String namespace, @javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull String body) throws ApiException {
    return this.updateFlow(id, namespace, tenant, body, Collections.emptyMap());
  }


  /**
   * Update a flow
   * 
   * @param id The flow id (required)
   * @param namespace The flow namespace (required)
   * @param tenant  (required)
   * @param body The flow source code (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return UpdateFlow200Response
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public UpdateFlow200Response updateFlow(@javax.annotation.Nonnull String id, @javax.annotation.Nonnull String namespace, @javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull String body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling updateFlow");
    }
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling updateFlow");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling updateFlow");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling updateFlow");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}/{id}"
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/x-yaml"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<UpdateFlow200Response> localVarReturnType = new TypeReference<UpdateFlow200Response>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "PUT",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Update a complete namespace from json object
   * All flow will be created / updated for this namespace. Flow that already created but not in &#x60;flows&#x60; will be deleted if the query delete is &#x60;true&#x60;
   * @param delete If missing flow should be deleted (required)
   * @param namespace The flow namespace (required)
   * @param tenant  (required)
   * @param flow A list of flows (required)
   * @return UpdateFlowsInNamespaceFromJson200Response
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public UpdateFlowsInNamespaceFromJson200Response updateFlowsInNamespaceFromJson(@javax.annotation.Nonnull Boolean delete, @javax.annotation.Nonnull String namespace, @javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull List<Flow> flow) throws ApiException {
    return this.updateFlowsInNamespaceFromJson(delete, namespace, tenant, flow, Collections.emptyMap());
  }


  /**
   * Update a complete namespace from json object
   * All flow will be created / updated for this namespace. Flow that already created but not in &#x60;flows&#x60; will be deleted if the query delete is &#x60;true&#x60;
   * @param delete If missing flow should be deleted (required)
   * @param namespace The flow namespace (required)
   * @param tenant  (required)
   * @param flow A list of flows (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return UpdateFlowsInNamespaceFromJson200Response
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public UpdateFlowsInNamespaceFromJson200Response updateFlowsInNamespaceFromJson(@javax.annotation.Nonnull Boolean delete, @javax.annotation.Nonnull String namespace, @javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull List<Flow> flow, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = flow;
    
    // verify the required parameter 'delete' is set
    if (delete == null) {
      throw new ApiException(400, "Missing the required parameter 'delete' when calling updateFlowsInNamespaceFromJson");
    }
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling updateFlowsInNamespaceFromJson");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling updateFlowsInNamespaceFromJson");
    }
    
    // verify the required parameter 'flow' is set
    if (flow == null) {
      throw new ApiException(400, "Missing the required parameter 'flow' when calling updateFlowsInNamespaceFromJson");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("delete", delete));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json", "application/x-yaml"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<UpdateFlowsInNamespaceFromJson200Response> localVarReturnType = new TypeReference<UpdateFlowsInNamespaceFromJson200Response>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Update a single task on a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param taskId The task id (required)
   * @param tenant  (required)
   * @param task The task (required)
   * @return Flow
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public Flow updateTask(@javax.annotation.Nonnull String namespace, @javax.annotation.Nonnull String id, @javax.annotation.Nonnull String taskId, @javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull Task task) throws ApiException {
    return this.updateTask(namespace, id, taskId, tenant, task, Collections.emptyMap());
  }


  /**
   * Update a single task on a flow
   * 
   * @param namespace The flow namespace (required)
   * @param id The flow id (required)
   * @param taskId The task id (required)
   * @param tenant  (required)
   * @param task The task (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return Flow
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public Flow updateTask(@javax.annotation.Nonnull String namespace, @javax.annotation.Nonnull String id, @javax.annotation.Nonnull String taskId, @javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull Task task, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = task;
    
    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(400, "Missing the required parameter 'namespace' when calling updateTask");
    }
    
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling updateTask");
    }
    
    // verify the required parameter 'taskId' is set
    if (taskId == null) {
      throw new ApiException(400, "Missing the required parameter 'taskId' when calling updateTask");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling updateTask");
    }
    
    // verify the required parameter 'task' is set
    if (task == null) {
      throw new ApiException(400, "Missing the required parameter 'task' when calling updateTask");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/{namespace}/{id}/{taskId}"
      .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(apiClient.parameterToString(namespace)))
      .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(apiClient.parameterToString(id)))
      .replaceAll("\\{" + "taskId" + "\\}", apiClient.escapeString(apiClient.parameterToString(taskId)))
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<Flow> localVarReturnType = new TypeReference<Flow>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "PATCH",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Validate a list of flows
   * 
   * @param tenant  (required)
   * @param body A list of flows source code in a single string (required)
   * @return List&lt;ValidateConstraintViolation&gt;
   * @throws ApiException if fails to make API call
   */
  public List<ValidateConstraintViolation> validateFlows(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull String body) throws ApiException {
    return this.validateFlows(tenant, body, Collections.emptyMap());
  }


  /**
   * Validate a list of flows
   * 
   * @param tenant  (required)
   * @param body A list of flows source code in a single string (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return List&lt;ValidateConstraintViolation&gt;
   * @throws ApiException if fails to make API call
   */
  public List<ValidateConstraintViolation> validateFlows(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull String body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling validateFlows");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling validateFlows");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/validate"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/x-yaml"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<List<ValidateConstraintViolation>> localVarReturnType = new TypeReference<List<ValidateConstraintViolation>>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Validate a task
   * 
   * @param section The type of task (required)
   * @param tenant  (required)
   * @param body A task definition that can be from tasks or triggers (required)
   * @return ValidateConstraintViolation
   * @throws ApiException if fails to make API call
   */
  public ValidateConstraintViolation validateTask(@javax.annotation.Nonnull FlowControllerTaskValidationType section, @javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull String body) throws ApiException {
    return this.validateTask(section, tenant, body, Collections.emptyMap());
  }


  /**
   * Validate a task
   * 
   * @param section The type of task (required)
   * @param tenant  (required)
   * @param body A task definition that can be from tasks or triggers (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ValidateConstraintViolation
   * @throws ApiException if fails to make API call
   */
  public ValidateConstraintViolation validateTask(@javax.annotation.Nonnull FlowControllerTaskValidationType section, @javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull String body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'section' is set
    if (section == null) {
      throw new ApiException(400, "Missing the required parameter 'section' when calling validateTask");
    }
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling validateTask");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling validateTask");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/validate/task"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("section", section));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/x-yaml", "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ValidateConstraintViolation> localVarReturnType = new TypeReference<ValidateConstraintViolation>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Validate trigger
   * 
   * @param tenant  (required)
   * @param body The trigger (required)
   * @return ValidateConstraintViolation
   * @throws ApiException if fails to make API call
   */
  public ValidateConstraintViolation validateTrigger(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull String body) throws ApiException {
    return this.validateTrigger(tenant, body, Collections.emptyMap());
  }


  /**
   * Validate trigger
   * 
   * @param tenant  (required)
   * @param body The trigger (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ValidateConstraintViolation
   * @throws ApiException if fails to make API call
   */
  public ValidateConstraintViolation validateTrigger(@javax.annotation.Nonnull String tenant, @javax.annotation.Nonnull String body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'tenant' is set
    if (tenant == null) {
      throw new ApiException(400, "Missing the required parameter 'tenant' when calling validateTrigger");
    }
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling validateTrigger");
    }
    
    // create path and map variables
    String localVarPath = "/api/v1/{tenant}/flows/validate/trigger"
      .replaceAll("\\{" + "tenant" + "\\}", apiClient.escapeString(apiClient.parameterToString(tenant)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    TypeReference<ValidateConstraintViolation> localVarReturnType = new TypeReference<ValidateConstraintViolation>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  @Override
  public <T> T invokeAPI(String url, String method, Object request, TypeReference<T> returnType, Map<String, String> additionalHeaders) throws ApiException {
    String localVarPath = url.replace(apiClient.getBaseURL(), "");
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarHeaderParams.putAll(additionalHeaders);

    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "basicAuth", "bearerAuth" };

    return apiClient.invokeAPI(
      localVarPath,
        method,
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        request,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        returnType
    );
  }
}
